//! Distributed signature services
//!
//! Create and verify partial signatures in multisignature protocol.

use std::collections::HashMap;
use std::convert::TryInto;
use std::error::Error;
use std::io::Write;

use crate::dkg;
use crate::poly;
use crate::sign;
use crate::utils;

use curve25519_dalek::scalar::Scalar;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256, Sha512};

use crate::curve_traits;
use crate::ristretto_curve;
use curve_traits::{ECPoint, ECScalar};
use ristretto_curve::{FE, GE, SK};

use dkg::DistKeyShare;
use poly::{PriShare, PubPoly, PubShare};
use utils::bitwise_eq;

/// DSS holds the information used to issue partial signatures as well as to
/// compute the distributed schnorr signature.
#[derive(Serialize, Deserialize, Debug)]
pub struct DSS {
    secret: FE,
    public: GE,
    index: u32,
    participants: Vec<GE>,
    t: u32,
    long: DistKeyShare,
    random: DistKeyShare,
    long_poly: PubPoly,
    random_poly: PubPoly,
    msg: Vec<u8>, // the message to sign
    partials: Vec<PriShare<FE>>,
    partials_idx: HashMap<u32, bool>,
    signed: bool,
    session_id: Vec<u8>,
}

/// PartialSig is partial representation of the final distributed signature. It
/// must be sent to each of the other participants.
#[derive(Serialize, Deserialize)]
pub struct PartialSig {
    partial: PriShare<FE>,
    session_id: Vec<u8>,
    signature: Vec<u8>,
}

impl DSS {
    /// Create DSS struct out of the longterm secret of this
    /// node, the list of participants, the longterm and random distributed key
    /// (generated by the dkg package), the message to sign and finally the T
    /// threshold. It returns an error if the public key of the secret can't be found
    /// in the list of participants.
    pub fn new(
        secret: FE,
        participants: Vec<GE>,
        long: DistKeyShare,
        random: DistKeyShare,
        msg: Vec<u8>,
        t: u32,
    ) -> Result<DSS, Box<dyn Error>> {
        let generator = GE::generator();
        let pub_k: GE = generator.scalar_mul(&secret.get_element());

        let index = participants
            .iter()
            .position(|p| p == &pub_k)
            .ok_or_else(|| simple_error!("dss: public key not found in list of participants"))?;

        Ok(DSS {
            secret,
            public: pub_k,
            index: index as u32,
            participants,
            long_poly: poly::PubPoly::new(generator, long.get_commitments().to_vec()),
            random_poly: poly::PubPoly::new(generator, random.get_commitments().to_vec()),
            msg,
            t,
            session_id: session_id(&long, &random).to_vec(),
            long,
            random,
            partials_idx: HashMap::new(),
            partials: Vec::new(),
            signed: false,
        })
    }

    /// partial_sig generates the partial signature related to this DSS. This
    /// PartialSig can be broadcasted to every other participant or only to a
    /// trusted combiner as described in the paper.
    /// The signature format is compatible with EdDSA verification implementations.
    pub fn partial_sig(&mut self) -> Result<PartialSig, Box<dyn Error>> {
        let alpha: FE = self.long.get_pri_share().v;
        let beta: FE = self.random.get_pri_share().v;

        let hash: FE = self.hash_sig();

        let right: FE = hash.mul(&alpha.get_element());
        let right: FE = right.add(&beta.get_element());

        let part_pri_share: PriShare<FE> = PriShare {
            i: self.index,
            v: right,
        };
        let part_hash: [u8; 32] = PartialSig::hash(&part_pri_share, &self.session_id)?;

        let signature = sign::sign_msg(
            self.secret.get_element().to_bytes(),
            self.public.get_element().to_bytes(),
            &part_hash,
            &self.index.to_le_bytes(),
        )?;

        let ps = PartialSig {
            partial: part_pri_share.clone(),
            session_id: self.session_id.clone(),
            signature,
        };

        if !self.signed {
            self.partials_idx.insert(self.index, true);
            self.partials.push(part_pri_share);
            self.signed = true;
        }

        Ok(ps)
    }

    /// process_partial_sig takes a PartialSig from another participant and stores it
    /// for generating the distributed signature. It returns an error if the index is
    /// wrong, or the signature is invalid or if a partial signature has already been
    /// received by the same peer. To know whether the distributed signature can be
    /// computed after this call, one can use the enough_partial_sigs method.
    /// not done yet
    pub fn process_partial_sig(&mut self, ps: &PartialSig) -> Result<(), Box<dyn Error>> {
        let pub_k = self
            .participants
            .get(ps.partial.i as usize)
            .ok_or_else(|| simple_error!("dss: partial signature with invalid index"))?;

        let msg: [u8; 32] = PartialSig::hash(&ps.partial, &self.session_id)?;

        sign::verify_signature(
            pub_k.get_element().to_bytes().as_ref(),
            ps.signature.as_ref(),
            msg.as_ref(),
            ps.partial.i.to_le_bytes().as_ref(),
        )
        .map_err(|e| simple_error!("dss: invalid signature in PartialSig: {}", e))?;

        if !bitwise_eq(ps.session_id.as_ref(), self.session_id.as_ref()) {
            bail!("dss: session id do not match")
        }

        if self.partials_idx.contains_key(&ps.partial.i) {
            bail!("dss: partial signature already received from peer")
        }

        let hash: FE = self.hash_sig();
        let rand_share: PubShare<GE> = self.random_poly.eval(ps.partial.i);
        let long_share: PubShare<GE> = self.long_poly.eval(ps.partial.i);

        let right: GE = long_share.v.scalar_mul(&hash.get_element());
        let right: GE = right.add_point(&rand_share.v.get_element());
        let generator = GE::generator();
        let left: GE = generator.scalar_mul(&ps.partial.v.get_element());

        if left != right {
            bail!("dss: partial signature not valid")
        }

        self.partials_idx.insert(ps.partial.i, true);
        self.partials.push(ps.partial.clone());

        Ok(())
    }

    fn hash_sig(&self) -> FE {
        // H(R || A || msg) with
        //  * R = distributed random "key"
        //  * A = distributed public key
        //  * msg = msg to sign
        let mut hasher = Sha512::new();
        hasher.input(self.random.get_commitments()[0].get_element().to_bytes());
        hasher.input(self.long.get_commitments()[0].get_element().to_bytes());
        hasher.write_all(self.msg.as_ref()).unwrap();

        let scalar = SK::from_hash(hasher);
        FE::from(scalar)
    }

    /// enough_partial_sigs returns true if there are enough partial signature to compute
    /// the distributed signature. It returns false otherwise. If there are enough
    /// partial signatures, one can issue the signature with signature().
    pub fn enough_partial_sigs(&self) -> bool {
        self.partials.len() as u32 >= self.t
    }

    /// signature computes the distributed signature from the list of partial
    /// signatures received. It returns an error if there are not enough partial
    /// signatures. The signature is compatible with the EdDSA verification
    /// algorithm.
    pub fn signature(&self) -> Result<Vec<u8>, Box<dyn Error>> {
        if !self.enough_partial_sigs() {
            bail!("dkg: not enough partial signatures to sign")
        }
        let gamma: FE = poly::recover_secret(self.partials.as_slice(), self.t)?;

        // RandomPublic || gamma
        let mut buff: Vec<u8> = Vec::new();
        let rand_bytes = self.random.get_commitments()[0].get_element().to_bytes();
        buff.extend_from_slice(&rand_bytes);
        let gamma_bytes = gamma.get_element().to_bytes();
        buff.extend_from_slice(&gamma_bytes);
        Ok(buff)
    }
}

impl PartialSig {
    /// Hash of PriShare and session_id to sign later
    pub fn hash(partial: &PriShare<FE>, session_id: &[u8]) -> Result<[u8; 32], Box<dyn Error>> {
        let mut hasher = Sha256::new();
        let partial_hash = partial.hash();
        hasher.input(&partial_hash);
        hasher.input(session_id);
        let result = hasher.result();
        Ok(result.try_into()?)
    }
}

/// verify uses a public key, a message and a signature. It will return Ok(boolean) indicating
/// if signature is valid. It will return Err if msg or sig bytes are of invalid length
pub fn verify(public: GE, msg: &[u8], sig: &[u8]) -> Result<bool, Box<dyn Error>> {
    if sig.len() != 64 as usize {
        bail!(
            "dss: Signature length invalid, expect 64 but got {}",
            sig.len()
        )
    }

    let r = GE::from_bytes(&sig[..32]).map_err(|_| {
        simple_error!("dss: Error while create point from bytes in sig verification")
    })?;

    let scalar_bytes: [u8; 32] = sig[32..].try_into()?;
    let ristr_s: Scalar = Scalar::from_bytes_mod_order(scalar_bytes);
    let s = FE::from(ristr_s);

    // reconstruct h = H(R || Public || Msg)
    let p_buff = public.get_element().to_bytes();
    let mut hash = Sha512::new();
    hash.input(&sig[..32]);
    hash.input(p_buff);
    hash.input(msg);

    let h = FE::from(SK::from_hash(hash));
    // reconstruct S == k*A + R
    let generator = GE::generator();
    let ss: GE = generator.scalar_mul(&s.get_element());
    let ha: GE = public.scalar_mul(&h.get_element());
    let rha: GE = ha.add_point(&r.get_element());

    Ok(rha == ss)
}

fn session_id(a: &DistKeyShare, b: &DistKeyShare) -> [u8; 32] {
    let mut hasher = Sha256::new();

    for p in a.get_commitments().iter() {
        hasher.input(p.get_element().to_bytes());
    }

    for p in b.get_commitments().iter() {
        hasher.input(p.get_element().to_bytes());
    }

    hasher
        .result()
        .as_slice()
        .try_into()
        .expect("Slice with incorrect length")
}
