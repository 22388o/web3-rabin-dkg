//! Distributed signature services
//!
//! Create and verify partial signatures in multisignature protocol.

use std::collections::HashMap;
use std::convert::TryInto;
use std::error::Error;
use std::io::Write;

use crate::dkg;
use crate::poly;
use crate::sign;
use crate::utils;

use curve25519_dalek::scalar::Scalar;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256, Sha512};

use crate::curve_traits;
use crate::ristretto_curve;
use curve_traits::{ECPoint, ECScalar};
use ristretto_curve::{FE, GE, SK};

use dkg::DistKeyShare;
use poly::{PriShare, PubPoly, PubShare};
use utils::bitwise_eq;

/// DSS holds the information used to issue partial signatures as well as to
/// compute the distributed schnorr signature.
#[derive(Serialize, Deserialize, Debug)]
pub struct DSS {
    secret: FE,
    public: GE,
    index: u32,
    participants: Vec<GE>,
    t: u32,
    long: DistKeyShare,
    random: DistKeyShare,
    long_poly: PubPoly,
    random_poly: PubPoly,
    msg: Vec<u8>, // the message to sign
    partials: Vec<PriShare<FE>>,
    partials_idx: HashMap<u32, bool>,
    signed: bool,
    session_id: Vec<u8>,
}

/// PartialSig is partial representation of the final distributed signature. It
/// must be sent to each of the other participants.
#[derive(Serialize, Deserialize)]
pub struct PartialSig {
    partial: PriShare<FE>,
    session_id: Vec<u8>,
    signature: Vec<u8>,
}

impl DSS {
    /// Create DSS struct out of the longterm secret of this
    /// node, the list of participants, the longterm and random distributed key
    /// (generated by the dkg package), the message to sign and finally the T
    /// threshold. It returns an error if the public key of the secret can't be found
    /// in the list of participants.
    pub fn new(
        secret: FE,
        participants: Vec<GE>,
        long: DistKeyShare,
        random: DistKeyShare,
        msg: Vec<u8>,
        t: u32,
    ) -> Result<DSS, Box<dyn Error>> {
        let generator = GE::generator();
        let pub_k: GE = generator.scalar_mul(&secret.get_element());

        let index = participants
            .iter()
            .position(|p| p == &pub_k)
            .ok_or_else(|| simple_error!("dss: public key not found in list of participants"))?;

        Ok(DSS {
            secret,
            public: pub_k,
            index: index as u32,
            participants,
            long_poly: poly::PubPoly::new(generator, long.get_commitments().to_vec()),
            random_poly: poly::PubPoly::new(generator, random.get_commitments().to_vec()),
            msg,
            t,
            session_id: session_id(&long, &random).to_vec(),
            long,
            random,
            partials_idx: HashMap::new(),
            partials: Vec::new(),
            signed: false,
        })
    }

    /// partial_sig generates the partial signature related to this DSS. This
    /// PartialSig can be broadcasted to every other participant or only to a
    /// trusted combiner as described in the paper.
    /// The signature format is compatible with EdDSA verification implementations.
    pub fn partial_sig(&mut self) -> Result<PartialSig, Box<dyn Error>> {
        let alpha: FE = self.long.get_pri_share().v;
        let beta: FE = self.random.get_pri_share().v;

        let hash: FE = self.hash_sig();

        let right: FE = hash.mul(&alpha.get_element());
        let right: FE = right.add(&beta.get_element());

        let part_pri_share: PriShare<FE> = PriShare {
            i: self.index,
            v: right,
        };
        let part_hash: [u8; 32] = PartialSig::hash(&part_pri_share, &self.session_id)?;

        let signature = sign::sign_msg(
            self.secret.get_element().to_bytes(),
            self.public.get_element().to_bytes(),
            &part_hash,
            &self.index.to_le_bytes(),
        )?;

        let ps = PartialSig {
            partial: part_pri_share.clone(),
            session_id: self.session_id.clone(),
            signature,
        };

        if !self.signed {
            self.partials_idx.insert(self.index, true);
            self.partials.push(part_pri_share);
            self.signed = true;
        }

        Ok(ps)
    }

    /// process_partial_sig takes a PartialSig from another participant and stores it
    /// for generating the distributed signature. It returns an error if the index is
    /// wrong, or the signature is invalid or if a partial signature has already been
    /// received by the same peer. To know whether the distributed signature can be
    /// computed after this call, one can use the enough_partial_sigs method.
    /// not done yet
    pub fn process_partial_sig(&mut self, ps: &PartialSig) -> Result<(), Box<dyn Error>> {
        let pub_k = self
            .participants
            .get(ps.partial.i as usize)
            .ok_or_else(|| simple_error!("dss: partial signature with invalid index"))?;

        let msg: [u8; 32] = PartialSig::hash(&ps.partial, &self.session_id)?;

        sign::verify_signature(
            pub_k.get_element().to_bytes().as_ref(),
            ps.signature.as_ref(),
            msg.as_ref(),
            ps.partial.i.to_le_bytes().as_ref(),
        )
        .map_err(|e| simple_error!("dss: invalid signature in PartialSig: {}", e))?;

        if !bitwise_eq(ps.session_id.as_ref(), self.session_id.as_ref()) {
            bail!("dss: session id do not match")
        }

        if self.partials_idx.contains_key(&ps.partial.i) {
            bail!("dss: partial signature already received from peer")
        }

        let hash: FE = self.hash_sig();
        let rand_share: PubShare<GE> = self.random_poly.eval(ps.partial.i);
        let long_share: PubShare<GE> = self.long_poly.eval(ps.partial.i);

        let right: GE = long_share.v.scalar_mul(&hash.get_element());
        let right: GE = right.add_point(&rand_share.v.get_element());
        let generator = GE::generator();
        let left: GE = generator.scalar_mul(&ps.partial.v.get_element());

        if left != right {
            bail!("dss: partial signature not valid")
        }

        self.partials_idx.insert(ps.partial.i, true);
        self.partials.push(ps.partial.clone());

        Ok(())
    }

    fn hash_sig(&self) -> FE {
        // H(R || A || msg) with
        //  * R = distributed random "key"
        //  * A = distributed public key
        //  * msg = msg to sign
        let mut hasher = Sha512::new();
        hasher.input(self.random.get_commitments()[0].get_element().to_bytes());
        hasher.input(self.long.get_commitments()[0].get_element().to_bytes());
        hasher.write_all(self.msg.as_ref()).unwrap();

        let scalar = SK::from_hash(hasher);
        FE::from(scalar)
    }

    /// enough_partial_sigs returns true if there are enough partial signature to compute
    /// the distributed signature. It returns false otherwise. If there are enough
    /// partial signatures, one can issue the signature with signature().
    pub fn enough_partial_sigs(&self) -> bool {
        self.partials.len() as u32 >= self.t
    }

    /// signature computes the distributed signature from the list of partial
    /// signatures received. It returns an error if there are not enough partial
    /// signatures. The signature is compatible with the EdDSA verification
    /// algorithm.
    pub fn signature(&self) -> Result<Vec<u8>, Box<dyn Error>> {
        if !self.enough_partial_sigs() {
            bail!("dkg: not enough partial signatures to sign")
        }
        let gamma: FE = poly::recover_secret(self.partials.as_slice(), self.t)?;

        // RandomPublic || gamma
        let mut buff: Vec<u8> = Vec::new();
        let rand_bytes = self.random.get_commitments()[0].get_element().to_bytes();
        buff.extend_from_slice(&rand_bytes);
        let gamma_bytes = gamma.get_element().to_bytes();
        buff.extend_from_slice(&gamma_bytes);
        Ok(buff)
    }
}

impl PartialSig {
    /// Hash of PriShare and session_id to sign later
    pub fn hash(partial: &PriShare<FE>, session_id: &[u8]) -> Result<[u8; 32], Box<dyn Error>> {
        let mut hasher = Sha256::new();
        let partial_hash = partial.hash();
        hasher.input(&partial_hash);
        hasher.input(session_id);
        let result = hasher.result();
        Ok(result.try_into()?)
    }
}

/// verify uses a public key, a message and a signature. It will return Ok(boolean) indicating
/// if signature is valid. It will return Err if msg or sig bytes are of invalid length
pub fn verify(public: GE, msg: &[u8], sig: &[u8]) -> Result<bool, Box<dyn Error>> {
    if sig.len() != 64 as usize {
        bail!(
            "dss: Signature length invalid, expect 64 but got {}",
            sig.len()
        )
    }

    let r = GE::from_bytes(&sig[..32]).map_err(|_| {
        simple_error!("dss: Error while create point from bytes in sig verification")
    })?;

    let scalar_bytes: [u8; 32] = sig[32..].try_into()?;
    let ristr_s: Scalar = Scalar::from_bytes_mod_order(scalar_bytes);
    let s = FE::from(ristr_s);

    // reconstruct h = H(R || Public || Msg)
    let p_buff = public.get_element().to_bytes();
    let mut hash = Sha512::new();
    hash.input(&sig[..32]);
    hash.input(p_buff);
    hash.input(msg);

    let h = FE::from(SK::from_hash(hash));
    // reconstruct S == k*A + R
    let generator = GE::generator();
    let ss: GE = generator.scalar_mul(&s.get_element());
    let ha: GE = public.scalar_mul(&h.get_element());
    let rha: GE = ha.add_point(&r.get_element());

    Ok(rha == ss)
}

fn session_id(a: &DistKeyShare, b: &DistKeyShare) -> [u8; 32] {
    let mut hasher = Sha256::new();

    for p in a.get_commitments().iter() {
        hasher.input(p.get_element().to_bytes());
    }

    for p in b.get_commitments().iter() {
        hasher.input(p.get_element().to_bytes());
    }

    hasher
        .result()
        .as_slice()
        .try_into()
        .expect("Slice with incorrect length")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::curve_traits;
    use crate::ristretto_curve;
    use curve_traits::{ECPoint, ECScalar};
    use dkg::*;
    use ristretto_curve::{FE, GE};
    use schnorrkel::context::signing_context;
    use schnorrkel::keys::Keypair;
    use schnorrkel::Signature;

    struct InitData {
        nb_verifiers: u32,
        parts_pub: Vec<GE>,
        parts_sec: Vec<FE>,
        longterms: Vec<DistKeyShare>,
        randoms: Vec<DistKeyShare>,
        dss: Vec<DSS>,
    }

    fn setup(nb_verifiers: u32) -> InitData {
        let mut parts_sec: Vec<FE> = Vec::new();
        let mut parts_pub: Vec<GE> = Vec::new();

        for _ in 0..nb_verifiers {
            let (scalar, point) = gen_pair();
            parts_sec.push(scalar);
            parts_pub.push(point);
        }

        let longterms: Vec<DistKeyShare> = gen_dist_secret(&parts_sec, &parts_pub, nb_verifiers);
        let randoms: Vec<DistKeyShare> = gen_dist_secret(&parts_sec, &parts_pub, nb_verifiers);

        InitData {
            nb_verifiers,
            parts_pub,
            parts_sec,
            longterms,
            randoms,
            dss: Vec::new(),
        }
    }

    fn gen_pair() -> (FE, GE) {
        let generator = GE::generator();
        let g_scalar: FE = ECScalar::new_random();
        let g_point: GE = generator.scalar_mul(&g_scalar.get_element());
        (g_scalar, g_point)
    }

    fn gen_dist_secret(
        parts_sec: &[FE],
        parts_pub: &[GE],
        participants_count: u32,
    ) -> Vec<DistKeyShare> {
        let mut dkgs: Vec<DistKeyGenerator> = Vec::new();
        for ind in 0..participants_count {
            let dkg: DistKeyGenerator = DistKeyGenerator::new(
                parts_sec[ind as usize],
                parts_pub.to_vec(),
                participants_count / 2 + 1,
            )
            .unwrap();
            dkgs.push(dkg);
        }
        // full secret sharing exchange
        // 1. broadcast deals
        let mut resps: Vec<Response> = Vec::new();
        for i in 0..participants_count {
            let deals = dkgs[i as usize].deals().unwrap();
            for (&j, deal) in deals.iter() {
                let resp: Response = dkgs[j as usize].process_deal(deal).unwrap();

                assert!(resp.response.approved);

                resps.push(resp);
            }
        }
        // 2. Broadcast responses
        for r in resps.iter() {
            for ind in 0..participants_count {
                let dkg: &mut DistKeyGenerator = &mut dkgs[ind as usize];
                if r.response.index != dkg.index() {
                    let j = dkg.process_response(r).unwrap();

                    assert!(j.is_none());
                }
            }
        }
        // 3. Broadcast secret commitment
        for ind in 0..participants_count as usize {
            let scs: SecretCommits = dkgs[ind].secret_commits().unwrap();
            for (ind2, dkg2) in dkgs.iter_mut().enumerate() {
                if ind == ind2 {
                    continue;
                }
                let cc = dkg2.process_secret_commit(&scs).unwrap().is_none();

                assert!(cc);
            }
        }

        // 5. reveal shares
        dkgs.iter()
            .map(DistKeyGenerator::dist_key_share)
            .collect::<Result<_, _>>()
            .unwrap()
    }

    fn get_dss(i: u32, init_data: &InitData) -> DSS {
        DSS::new(
            init_data.parts_sec[i as usize],
            init_data.parts_pub.clone(),
            init_data.longterms[i as usize].clone(),
            init_data.randoms[i as usize].clone(),
            b"hello DSS".to_vec(),
            init_data.nb_verifiers / 2 + 1,
        )
        .expect("Failed to create DSS")
    }

    fn custom_signature() -> Vec<u8> {
        let keypair: Keypair = Keypair::generate_with(utils::rand_hack());
        let context = signing_context(b"some context");
        let message: &[u8] = b"Very secret message";
        let signature: Signature = keypair.sign(context.bytes(message));
        signature.to_bytes().to_vec()
    }

    #[test]
    fn test_dss_new() {
        let init_data: InitData = setup(7);

        DSS::new(
            init_data.parts_sec[0],
            init_data.parts_pub.clone(),
            init_data.longterms[0].clone(),
            init_data.randoms[0].clone(),
            b"hello DSS".to_vec(),
            4,
        )
        .expect("Must work fine, correct secret");

        DSS::new(
            ECScalar::new_random(),
            init_data.parts_pub.clone(),
            init_data.longterms[0].clone(),
            init_data.randoms[0].clone(),
            b"hello DSS".to_vec(),
            4,
        )
        .expect_err("Must fail, incorrect secret");
    }

    #[test]
    fn test_dss_partial_sigs() {
        let init_data: InitData = setup(7);

        let mut dss0: DSS = get_dss(0, &init_data);
        let mut dss1: DSS = get_dss(1, &init_data);

        dss0.partial_sig().unwrap();
        assert_eq!(1, dss0.partials.len());
        // second time should not affect list
        let mut ps0: PartialSig = dss0.partial_sig().unwrap();

        assert_eq!(1, dss0.partials.len());

        // wrong index
        let correct_i: u32 = ps0.partial.i;
        ps0.partial.i = 100;
        dss1.process_partial_sig(&ps0)
            .expect_err("Must fail with wrong index");

        ps0.partial.i = correct_i;

        // wrong signature
        let correct_sig = ps0.signature.clone();
        ps0.signature = custom_signature();
        dss1.process_partial_sig(&ps0)
            .expect_err("Must fail with wrong signature");

        ps0.signature = correct_sig.clone();

        // invalid partial sig
        let correct_v = ps0.partial.v;
        ps0.partial.v = ECScalar::new_random();
        let msg: [u8; 32] = PartialSig::hash(&ps0.partial, &ps0.session_id).unwrap();

        let signature = sign::sign_msg(
            dss0.secret.get_element().to_bytes(),
            dss0.public.get_element().to_bytes(),
            &msg,
            &dss0.index.to_le_bytes(),
        )
        .unwrap();
        ps0.signature = signature;

        dss1.process_partial_sig(&ps0)
            .expect_err("Must fail with invalid partial sig");

        ps0.partial.v = correct_v;
        ps0.signature = correct_sig;

        dss1.process_partial_sig(&ps0).expect("Must work fine");

        dss1.process_partial_sig(&ps0)
            .expect_err("Must fail, partial sig already received");

        dss1.signature()
            .expect_err("Must fail, if not enough partial signatures, can't generate signature");

        // enough partial sigs ?
        for i in 2..init_data.nb_verifiers {
            let mut dss = get_dss(i, &init_data);
            let ps: PartialSig = dss.partial_sig().unwrap();

            dss1.process_partial_sig(&ps).expect("Must work fine");
        }

        assert!(dss1.enough_partial_sigs());
    }

    #[test]
    fn test_dss_signature() {
        let mut init_data: InitData = setup(7);

        let mut pss: Vec<PartialSig> = Vec::new();

        for ind in 0..init_data.nb_verifiers {
            let mut dss = get_dss(ind, &init_data);
            let part_sig = dss.partial_sig().unwrap();
            init_data.dss.push(dss);
            pss.push(part_sig);
        }
        for ind in 0..init_data.nb_verifiers {
            let dss = init_data.dss.get_mut(ind as usize).unwrap();
            for (i, k) in pss.iter().enumerate() {
                if ind != i as u32 {
                    let err = dss.process_partial_sig(k).is_ok();
                    assert!(err);
                }
            }
        }
        let dss0: &mut DSS = init_data.dss.get_mut(0 as usize).unwrap();
        let sig = dss0.signature().unwrap();

        let verif = verify(
            init_data
                .longterms
                .get(0 as usize)
                .unwrap()
                .get_public_key(),
            &dss0.msg,
            sig.as_ref(),
        )
        .unwrap();

        assert!(verif);

        let sig = custom_signature();
        let verif = verify(
            init_data
                .longterms
                .get(0 as usize)
                .unwrap()
                .get_public_key(),
            &dss0.msg,
            sig.as_ref(),
        )
        .unwrap();

        assert!(!verif);
    }
}
