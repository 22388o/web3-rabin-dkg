//! Distributed key generation (DKG) is a cryptographic process in which multiple
//! parties contribute to the calculation of a shared public and private key set.

use std::collections::{HashMap, HashSet};
use std::convert::TryInto;
use std::error::Error;
use std::io::Write;

use crate::curve_traits;
use crate::poly;
use crate::ristretto_curve;
use crate::sign;
use crate::utils;
use crate::vss;

use curve_traits::{ECPoint, ECScalar};
use ristretto_curve::{FE, GE};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

use poly::PriPoly;
use poly::PriShare;
use poly::PubPoly;
use utils::bitwise_eq;
use vss::Deal as vssDeal;
use vss::Dealer;
use vss::EncryptedDeal;
use vss::Justification as vssJustification;
use vss::Response as vssResponce;
use vss::Verifier as vssVerifier;

/// DistKeyShare holds the share of a distributed key for a participant.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DistKeyShare {
    // Coefficients of the public polynomial holding the public key
    commits: Vec<GE>,
    // Share of the distributed secret
    share: PriShare<FE>,
}

/// Deal holds the Deal for one participant as well as the index of the issuing
/// Dealer.
/// NOTE: Doing that in vss.rs would be possible but then the Dealer is always
/// assumed to be a member of the participants. It's only the case here.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Deal {
    // Index of the Dealer in the list of participants
    pub index: u32,
    // Deal issued for another participant
    pub deal: EncryptedDeal,
}

/// Response holds the Response from another participant as well as the index of
/// the target Dealer.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Response {
    // Index of the Dealer for which this response is for
    pub index: u32,
    // Response issued from another participant
    pub response: vssResponce,
}

/// Justification holds the Justification from a Dealer as well as the index of
/// the Dealer in question.
#[derive(Serialize, Deserialize, Clone)]
pub struct Justification {
    // Index of the Dealer who answered with this Justification
    pub index: u32,
    // Justification issued from the Dealer
    pub justification: vssJustification,
}

/// SecretCommits is sent during the distributed public key reconstruction phase,
/// basically a Feldman VSS scheme.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SecretCommits {
    // Index of the Dealer in the list of participants
    pub index: u32,
    // Commitments generated by the Dealer
    pub commitments: Vec<Vec<u8>>,
    // SessionID generated by the Dealer tied to the Deal
    pub session_id: Vec<u8>,
    // Signature from the Dealer
    pub signature: Vec<u8>,
}

/// ComplaintCommits is sent if the secret commitments revealed by a peer are not
/// valid.
#[derive(Serialize, Deserialize)]
pub struct ComplaintCommits {
    // Index of the Verifier _issuing_ the ComplaintCommit
    pub index: u32,
    // DealerIndex being the index of the Dealer who issued the SecretCommits
    pub dealer_index: u32,
    // Deal that has been given from the Dealer (at DealerIndex) to this node
    // (at Index)
    pub deal: vssDeal,
    // Signature made by the verifier
    pub signature: Vec<u8>,
}

/// ReconstructCommits holds the information given by a participant who reveals
/// the deal received from a peer that has received a ComplaintCommits.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ReconstructCommits {
    // Id of the session
    session_id: Vec<u8>,
    // Index of the verifier who received the deal
    index: u32,
    // DealerIndex is the index of the dealer who issued the Deal
    dealer_index: u32,
    // Share contained in the Deal
    share: PriShare<FE>,
    // Signature over all over fields generated by the issuing verifier
    signature: Vec<u8>,
}

/// DistKeyGenerator is the struct that runs the DKG protocol.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DistKeyGenerator {
    // Index of participant in the DKG protocol
    index: u32,
    // longterm secret, i.e. private key of the node
    long: FE,
    // longterm public key
    pub_key: GE,
    // pub keys of all the participants
    participants: Vec<GE>,
    // threshold
    t: u32,
    // vss dealer, to distribute secret committments
    dealer: Dealer,
    // verifiers to process deals from DKG with index i
    verifiers: HashMap<u32, vssVerifier>,
    // list of commitments to each secret polynomial
    commitments: HashMap<u32, PubPoly>,

    // Map of deals collected to reconstruct the full polynomial of a dealer.
    // The key is index of the dealer. Once there are enough ReconstructCommits
    // struct, this dkg will re-construct the polynomial and stores it into the
    // list of commitments.
    pending_reconstruct: HashMap<u32, Vec<ReconstructCommits>>,
    reconstructed: HashSet<u32>,
    sig_ctx: Vec<u8>,
}

impl DistKeyGenerator {
    /// longterm: the secret (private) key,
    /// participants: the list of participants pubkeys,
    /// t: threshold parameter
    ///
    /// It returns an error if the secret key's commitment can't
    /// be found in the list of participants.
    pub fn new(
        longterm: FE,
        participants: Vec<GE>,
        t: u32,
    ) -> Result<DistKeyGenerator, Box<dyn Error>> {
        let generator = GE::generator();
        let pub_k: GE = generator.scalar_mul(&longterm.get_element());

        let index = participants
            .iter()
            .position(|point| point == &pub_k)
            .ok_or_else(|| {
                simple_error!("dkg: own public key not found in list of participants")
            })?;

        // generate our dealer
        let own_secret = FE::new_random();
        let dealer = Dealer::new(longterm, own_secret, participants.clone(), t)?;

        Ok(DistKeyGenerator {
            index: index as u32,
            long: longterm,
            pub_key: pub_k,
            participants,
            t,
            dealer,
            verifiers: Default::default(),
            commitments: Default::default(),
            pending_reconstruct: Default::default(),
            reconstructed: Default::default(),
            sig_ctx: index.to_le_bytes().to_vec(),
        })
    }

    /// deals returns all the deals that must be broadcasted to all
    /// participants. The deal corresponding to this DKG is already added
    /// to this DKG and is omitted from the returned map. To know
    /// to which participant a deal belongs to, loop over the keys as indices in
    /// the list of participants.
    pub fn deals(&mut self) -> Result<HashMap<u32, Deal>, Box<dyn Error>> {
        let deals: Vec<EncryptedDeal> = self.dealer.encrypt_deals()?;

        debug_assert!(deals.len() == self.participants.len());

        let mut dist_deals: HashMap<u32, Deal> = HashMap::new();
        for (i, deal) in deals.into_iter().enumerate() {
            let dist_d = Deal {
                index: self.index,
                deal,
            };
            if i as u32 == self.index {
                if self.verifiers.contains_key(&self.index) {
                    // already processed our own deal
                    continue;
                }
                let resp: Response = self.process_deal(&dist_d)?;
                if !resp.response.approved {
                    bail!("dkg: own deal gave a complaint")
                }

                // If processed own deal correctly, set positive response in this
                // DKG's dealer's own verifier
                self.dealer.unsafe_set_response_dkg(self.index, true)?;
            } else {
                dist_deals.insert(i as u32, dist_d);
            }
        }

        Ok(dist_deals)
    }

    /// process_deal takes a Deal created by deals() and stores and verifies it. It
    /// returns a Response to broadcast to every other participants. It returns an
    /// error in case the deal has already been stored, or if the deal is incorrect
    pub fn process_deal(&mut self, dd: &Deal) -> Result<Response, Box<dyn Error>> {
        // public key of the dealer
        let pub_k = self
            .participants
            .get(dd.index as usize)
            .ok_or_else(|| simple_error!("dkg: dist deal out of bounds index"))?;

        if self.verifiers.contains_key(&dd.index) {
            bail!("dkg: already received dist deal from same index");
        }

        // verifier receiving the dealer's deal
        let mut ver: vssVerifier = vssVerifier::new(self.long, *pub_k, self.participants.clone())?;
        let resp: vssResponce = ver.process_encrypted_deal(&dd.deal)?;

        // Set status_approval for the verifier that represents the participant
        // that distributed the Deal
        // We shouldn't check result here such as call unsafe bypass method
        ver.unsafe_set_response_dkg(dd.index, true)
            .unwrap_or_default();

        self.verifiers.insert(dd.index, ver);

        Ok(Response {
            index: dd.index,
            response: resp,
        })
    }

    /// process_response takes a response from every other peer. If the response
    /// designates the deal of another participants than this dkg, this dkg stores it
    /// and returns None or a possible error regarding the validity of the response.
    /// If the response designates a deal this dkg has issued, then the dkg will process
    /// the response, and returns a justification.
    pub fn process_response(
        &mut self,
        resp: &Response,
    ) -> Result<Option<Justification>, Box<dyn Error>> {
        let v: &mut vssVerifier = self
            .verifiers
            .get_mut(&resp.index)
            .ok_or_else(|| simple_error!("dkg: complaint received but no deal for it"))?;

        v.process_response(&resp.response)?;

        if resp.index != self.index {
            return Ok(None);
        }

        match self.dealer.process_response(&resp.response)? {
            Some(justification) => {
                // a justification for our own deal
                v.process_justification(&justification)?;

                Ok(Some(Justification {
                    index: self.index,
                    justification,
                }))
            }
            None => Ok(None),
        }
    }

    /// process_justification takes a justification and validates it. It returns an
    /// error in case the justification is wrong.
    pub fn process_justification(&mut self, j: &Justification) -> Result<(), Box<dyn Error>> {
        self.verifiers
            .get_mut(&j.index)
            .ok_or_else(|| simple_error!("dkg: Justification received but no deal for it"))?
            .process_justification(&j.justification)
    }

    /// set_timeout triggers the timeout on all verifiers, and thus makes sure
    /// all verifiers have either responded, or have a StatusComplaint response.
    pub fn set_timeout(&mut self) {
        for v in self.verifiers.values_mut() {
            v.set_timeout();
        }
    }

    /// certified returns true if at least t deals are certified (see
    /// vss.Verifier.deal_certified()). If the distribution is certified, the protocol
    /// can continue using d.SecretCommits().
    pub fn certified(&self) -> bool {
        self.qual().len() as u32 >= self.t
    }

    /// qual returns the index in the list of participants that forms the qualified
    /// set as described in the "New-DKG" protocol by Rabin. Basically, it consists
    /// of all participants that are not disqualified after having exchanged all
    /// deals, responses and justification. This is the set that is used to extract
    /// the distributed public key with secret_commits() and process_secret_commits().
    pub fn qual(&self) -> Vec<u32> {
        self.verifiers
            .iter()
            .filter(|(_, v)| v.deal_certified())
            .map(|(&i, _)| i)
            .collect()
    }

    /// Checks if verifier with idx is in qualified set
    pub fn is_in_qual(&self, idx: u32) -> bool {
        self.verifiers
            .get(&idx)
            .map(vssVerifier::deal_certified)
            .unwrap_or(false)
    }

    /// secret_commits returns the commitments of the coefficients of the secret
    /// polynomials. This secret commits must be broadcasted to every other
    /// participant and must be processed by process_secret_commits. In this manner,
    /// the coefficients are revealed through a Feldman VSS scheme.
    /// This dkg must have its deal certified, otherwise it returns an error. The
    /// secret_commits returned is already added to this dkg's list of secret_commits.
    pub fn secret_commits(&mut self) -> Result<SecretCommits, Box<dyn Error>> {
        if !self.dealer.deal_certified() {
            bail!("dkg: can't give SecretCommits if deal not certified");
        }
        let commits: Vec<Vec<u8>> = self.dealer.commits().unwrap();
        let session_id: Vec<u8> = self.dealer.get_session_id().to_vec();
        let msg: [u8; 32] = SecretCommits::hash(&commits, self.index)?;
        let signature = sign::sign_msg(
            self.long.get_element().to_bytes(),
            self.pub_key.get_element().to_bytes(),
            &msg,
            &self.index.to_le_bytes(),
        )?;
        let sc = SecretCommits {
            index: self.index,
            commitments: commits.clone(),
            session_id,
            signature,
        };
        // adding our own commitments
        let commits_p = commits
            .iter()
            .map(|c| GE::from_bytes(&c))
            .collect::<Result<Vec<_>, _>>()
            .unwrap();
        self.commitments.insert(
            self.index,
            poly::PubPoly::new(ECPoint::generator(), commits_p),
        );
        Ok(sc)
    }

    /// process_secret_commit takes a SecretCommits from every other participant and
    /// verifies and stores it. It returns an error in case the SecretCommits is
    /// invalid. In case the SecretCommits are valid, but this dkg can't verify its
    /// share, it returns a ComplaintCommits that must be broadcasted to every other
    /// participant. It returns Ok(None) otherwise.
    pub fn process_secret_commit(
        &mut self,
        sc: &SecretCommits,
    ) -> Result<Option<ComplaintCommits>, Box<dyn Error>> {
        let pub_k: &GE = self
            .participants
            .get(sc.index as usize)
            .ok_or_else(|| simple_error!("dkg: secretcommits received with index out of bounds"))?;

        if !self.is_in_qual(sc.index) {
            bail!("dkg: secretcommits from a non QUAL member");
        }

        // mapping verified by is_in_qual
        let v: &mut vssVerifier = self.verifiers.get_mut(&sc.index).unwrap();

        if !bitwise_eq(&v.session_id(), &sc.session_id) {
            bail!("dkg: secretcommits received with wrong session id");
        }

        let msg: [u8; 32] = SecretCommits::hash(&sc.commitments, sc.index)?;
        sign::verify_signature(
            &pub_k.get_element().to_bytes(),
            &sc.signature,
            &msg,
            &sc.index.to_le_bytes(),
        )
        .map_err(|e| simple_error!("dkg: invalid signature in SecretCommit: {}", e))?;

        let deal: vssDeal = v.get_deal().unwrap();
        let commitments: Vec<GE> = sc
            .commitments
            .iter()
            .map(|x| ECPoint::from_bytes(x))
            .collect::<Result<Vec<_>, _>>()
            .map_err(|x| simple_error!("Error while constructing point from bytes: {}", x))?;

        let polynomial: PubPoly = PubPoly::new(ECPoint::generator(), commitments);
        if polynomial.check(&deal.sec_share) {
            self.commitments.insert(sc.index, polynomial);
            Ok(None)
        } else {
            let msg: [u8; 32] = ComplaintCommits::hash(self.index, sc.index, &deal)?;
            let signature = sign::sign_msg(
                self.long.get_element().to_bytes(),
                self.pub_key.get_element().to_bytes(),
                &msg,
                &self.index.to_le_bytes(),
            )?;
            Ok(Some(ComplaintCommits {
                index: self.index,
                dealer_index: sc.index,
                deal,
                signature,
            }))
        }
    }

    /// process_complaints_commits takes any ComplaintCommits revealed through
    /// process_secret_commits() from other participants in QUAL. It returns the
    /// ReconstructCommits message that must be  broadcasted to every other participant
    /// in QUAL so the polynomial in question can be reconstructed.
    pub fn process_complaints_commits(
        &mut self,
        complaint_commits: &ComplaintCommits,
    ) -> Result<ReconstructCommits, Box<dyn Error>> {
        let issuer: &GE = self
            .participants
            .get(complaint_commits.index as usize)
            .ok_or_else(|| simple_error!("dkg: commitcomplaint with unknown issuer"))?;

        if !self.is_in_qual(complaint_commits.index) {
            bail!("dkg: complaintcommit from non-qual member");
        }

        let msg: [u8; 32] = ComplaintCommits::hash(
            complaint_commits.index,
            complaint_commits.dealer_index,
            &complaint_commits.deal,
        )?;
        sign::verify_signature(
            &issuer.get_element().to_bytes(),
            &complaint_commits.signature,
            &msg,
            &complaint_commits.index.to_le_bytes(),
        )
        .map_err(|e| simple_error!("dkg: invalid signature in SecretCommit: {}", e))?;

        let verifier = self
            .verifiers
            .get_mut(&complaint_commits.dealer_index)
            .ok_or_else(|| simple_error!("dkg: commit complaint linked to unknown verifier"))?;

        // the verification should pass for the deal, and not with the secret
        // commits. Verification 4) in DKG Rabin's paper.
        complaint_commits
            .deal
            .verify(verifier.verifiers(), verifier.session_id())
            .map_err(|e| simple_error!("dkg: verifying deal: {:?}", e))?;

        let secret_commit = self
            .commitments
            .get(&complaint_commits.dealer_index)
            .ok_or_else(|| simple_error!("dkg: complaint about non received commitments"))?;

        if secret_commit.check(&complaint_commits.deal.sec_share) {
            bail!("dkg: invalid complaint, deal verifying");
        }

        let deal = verifier.get_deal()?;

        self.commitments.remove(&complaint_commits.dealer_index);

        let msg: [u8; 32] =
            ReconstructCommits::hash(self.index, complaint_commits.dealer_index, &deal.sec_share)?;
        let signature = sign::sign_msg(
            self.long.get_element().to_bytes(),
            self.pub_key.get_element().to_bytes(),
            &msg,
            &self.index.to_le_bytes(),
        )?;

        let rc = ReconstructCommits {
            session_id: complaint_commits.deal.session_id.clone(),
            index: self.index,
            dealer_index: complaint_commits.dealer_index,
            share: deal.sec_share,
            signature,
        };

        self.pending_reconstruct
            .entry(complaint_commits.dealer_index)
            .or_default()
            .push(rc.clone());

        Ok(rc)
    }

    /// process_reconstruct_commits takes a ReconstructCommits message and stores it
    /// along any others. If there are enough messages to recover the coefficients of
    /// the public polynomials of the malicious dealer in question, then the
    /// polynomial is recovered.
    pub fn process_reconstruct_commits(
        &mut self,
        rs: &ReconstructCommits,
    ) -> Result<(), Box<dyn Error>> {
        if self.reconstructed.contains(&rs.dealer_index) {
            return Ok(());
        }

        if self.commitments.get(&rs.dealer_index).is_some() {
            bail!("dkg: commitments not invalidated by any complaints")
        }

        let pub_k = self
            .participants
            .get(rs.index as usize)
            .ok_or_else(|| simple_error!("dkg: reconstruct commits with invalid verifier index"))?;

        let msg: [u8; 32] = ReconstructCommits::hash(rs.index, rs.dealer_index, &rs.share)?;
        sign::verify_signature(
            pub_k.get_element().to_bytes().as_ref(),
            rs.signature.as_ref(),
            msg.as_ref(),
            rs.index.to_le_bytes().as_ref(),
        )
        .map_err(|e| simple_error!("dkg: invalid signature in ReconstructCommits: {}", e))?;

        let rec_comms = self.pending_reconstruct.entry(rs.dealer_index).or_default();
        // check if packet is already received or not
        // or if the session ID does not match the others
        for rec_comm in rec_comms.iter() {
            if rec_comm.index == rs.index {
                return Ok(());
            }
            if !bitwise_eq(rec_comm.session_id.as_ref(), rs.session_id.as_ref()) {
                bail!("dkg: reconstruct commits invalid session id");
            }
        }
        rec_comms.push(rs.clone());

        // check if we can reconstruct commitments
        if rec_comms.len() as u32 >= self.t {
            let mut shares: Vec<PriShare<FE>> = Vec::new();
            for el in rec_comms.iter() {
                shares.push(el.share.clone());
            }
            // error only happens when you have less than t shares, but we ensure
            // there are more just before
            let pri_poly: PriPoly = poly::recover_pri_poly(&mut shares, self.t as u32)?;
            let commit: PubPoly = pri_poly.commit(None);
            self.commitments.insert(rs.dealer_index, commit);
            // note it has been reconstructed.
            self.reconstructed.insert(rs.dealer_index);
            self.pending_reconstruct.remove(&rs.dealer_index);
        }

        Ok(())
    }

    /// finished returns true if the DKG has operated the protocol correctly and has
    /// all necessary information to generate the DistKeyShare() by itself. It
    /// returns false otherwise.
    pub fn finished(&self) -> bool {
        let mut nb: u32 = 0;
        for (i, v) in self.verifiers.iter() {
            if v.deal_certified() {
                nb += 1;
                // ALL QUAL members should have their commitments by now either given or
                // reconstructed.
                if self.commitments.get(i).is_none() {
                    return false;
                }
            }
        }
        nb >= self.t
    }

    /// dist_key_share generates the distributed key relative to this receiver
    /// It throws an error if something is wrong such as not enough deals received.
    /// The shared secret can be computed when all deals have been sent and
    /// basically consists of a public point and a share. The public point is the sum
    /// of all aggregated individual public commits of each individual secrets.
    /// the share is evaluated from the global Private Polynomial, basically SUM of
    /// fj(i) for a receiver i.
    pub fn dist_key_share(&self) -> Result<DistKeyShare, Box<dyn Error>> {
        if !self.certified() {
            bail!("dkg: distributed key not certified")
        }

        let mut sh: FE = ECScalar::zero();
        let mut pub_poly: Option<PubPoly> = None;
        for (i, v) in self.verifiers.iter() {
            if v.deal_certified() {
                // share of dist. secret = sum of all share received.
                let s: FE = v.get_deal().unwrap().sec_share.v;
                sh = sh.add(&s.get_element());
                // Dist. public key = sum of all revealed commitments
                let poly = self.commitments.get(&i).ok_or_else(|| {
                    simple_error!("dkg: protocol not finished: commitments from {} missing", i)
                })?;
                if pub_poly.is_none() {
                    // first polynomial we see (instead of generating n empty commits)
                    pub_poly.replace(poly.clone());
                    continue;
                }
                let sum_poly: PubPoly = pub_poly.unwrap().add(poly)?;
                pub_poly = Some(sum_poly);
            }
        }

        let (_, commits): (_, Vec<GE>) = pub_poly.unwrap().info();

        Ok(DistKeyShare {
            commits,
            share: PriShare {
                i: self.index,
                v: sh,
            },
        })
    }

    pub fn index(&self) -> u32 {
        self.index
    }
}

impl DistKeyShare {
    // get_public_key returns the public key associated with the distributed private key.
    pub fn get_public_key(&self) -> GE {
        self.commits[0]
    }

    pub fn get_pri_share(&self) -> PriShare<FE> {
        self.share.clone()
    }

    pub fn get_commitments(&self) -> &[GE] {
        &self.commits
    }
}

impl SecretCommits {
    /// hash returns the hash value of data used in the signature process.
    pub fn hash(commitments: &[Vec<u8>], index: u32) -> Result<[u8; 32], Box<dyn Error>> {
        let mut hasher = Sha256::new();
        hasher.write_all(b"secretcommits".as_ref()).unwrap();
        hasher.write_all(&index.to_le_bytes()).unwrap();
        for comm in commitments.iter() {
            hasher.write_all(comm.as_ref()).unwrap();
        }
        let result = hasher.result().as_slice().try_into()?;
        Ok(result)
    }
}

impl ComplaintCommits {
    /// hash returns the hash value of this struct used in the signature process.
    pub fn hash(index: u32, dealer_index: u32, deal: &vssDeal) -> Result<[u8; 32], Box<dyn Error>> {
        let deal_buff: Vec<u8> = bincode::serialize(deal)?;

        let mut hasher = Sha256::new();
        hasher.write_all(b"commitcomplaint".as_ref())?;
        hasher.write_all(&index.to_le_bytes())?;
        hasher.write_all(&dealer_index.to_le_bytes())?;
        hasher.write_all(deal_buff.as_ref())?;

        let result = hasher.result().as_slice().try_into()?;
        Ok(result)
    }
}

impl ReconstructCommits {
    /// hash returns the hash value of this struct used in the signature process.
    pub fn hash(
        index: u32,
        dealer_index: u32,
        sec_share: &PriShare<FE>,
    ) -> Result<[u8; 32], Box<dyn Error>> {
        let mut hasher = Sha256::new();
        hasher.write_all(b"reconstructcommits".as_ref())?;
        hasher.write_all(&index.to_le_bytes())?;
        hasher.write_all(&dealer_index.to_le_bytes())?;
        hasher.write_all(sec_share.hash().as_ref())?;

        let result = hasher.result().as_slice().try_into()?;
        Ok(result)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::curve_traits;
    use crate::poly;
    use crate::ristretto_curve;
    use curve_traits::{ECPoint, ECScalar};
    use ristretto_curve::{FE, GE};
    use schnorrkel::context::signing_context;
    use schnorrkel::{Keypair, Signature};

    struct InitData {
        parts_pub: Vec<GE>,
        parts_sec: Vec<FE>,
        dkgs: Vec<DistKeyGenerator>,
    }

    fn setup(nb_verifiers: u32) -> InitData {
        let mut parts_sec: Vec<FE> = Vec::new();
        let mut parts_pub: Vec<GE> = Vec::new();
        for _ in 0..nb_verifiers {
            let (scalar, point) = gen_pair();
            parts_sec.push(scalar);
            parts_pub.push(point);
        }
        let dkgs: Vec<DistKeyGenerator> =
            dkg_gen(parts_sec.clone(), parts_pub.clone(), nb_verifiers);
        InitData {
            parts_pub,
            parts_sec,
            dkgs,
        }
    }

    fn gen_pair() -> (FE, GE) {
        let generator = GE::generator();
        let g_scalar: FE = ECScalar::new_random();
        let g_point: GE = generator.scalar_mul(&g_scalar.get_element());
        (g_scalar, g_point)
    }

    fn dkg_gen(
        participants_sec: Vec<FE>,
        participants_pub: Vec<GE>,
        patricipants_count: u32,
    ) -> Vec<DistKeyGenerator> {
        participants_sec
            .iter()
            .map(|sec| {
                DistKeyGenerator::new(*sec, participants_pub.clone(), patricipants_count / 2 + 1)
            })
            .collect::<Result<_, _>>()
            .unwrap()
    }

    fn full_exchange(participants: &mut Vec<DistKeyGenerator>, all_participants: u32) {
        // full secret sharing exchange
        // 1. broadcast deals
        let mut resps: Vec<Response> = Vec::new();
        for dkg_ind in 0..all_participants as usize {
            let deals = participants[dkg_ind].deals().unwrap();
            for (&i, deal) in deals.iter() {
                let resp: Response = participants[i as usize].process_deal(deal).unwrap();

                assert!(resp.response.approved);

                resps.push(resp);
            }
        }
        // 2. broadcast response
        for r in resps.iter() {
            for dkg in participants.iter_mut() {
                if r.response.index != dkg.index {
                    let justification = dkg.process_response(r).unwrap();

                    assert!(justification.is_none());
                }
            }
        }
        // 3. make sure everyone has the same QUAL set
        for dkg1 in participants.iter() {
            for dkg2 in participants.iter() {
                assert!(dkg1.is_in_qual(dkg2.index));
            }
        }
    }

    fn custom_signature() -> Vec<u8> {
        let keypair: Keypair = Keypair::generate_with(utils::rand_hack());
        let context = signing_context(b"some context");
        let message: &[u8] = b"Very secret message";
        let signature: Signature = keypair.sign(context.bytes(message));
        signature.to_bytes().to_vec()
    }

    #[test]
    fn test_dkg_new_dist_key_generator() {
        let participants_count: u32 = 7;
        let init_data = setup(participants_count);

        let long: FE = init_data.parts_sec[0];
        let mut dkg_gen = DistKeyGenerator::new(
            long,
            init_data.parts_pub.clone(),
            participants_count / 2 + 1,
        )
        .unwrap();

        dkg_gen.secret_commits().unwrap_err();

        let (secret, _) = gen_pair();
        DistKeyGenerator::new(secret, init_data.parts_pub, participants_count / 2 + 1).unwrap_err();
    }

    #[test]
    fn test_dkg_deal() {
        let participants_count: u32 = 7;
        let mut init_data = setup(participants_count);

        let dkg: &mut DistKeyGenerator = init_data.dkgs.get_mut(0 as usize).unwrap();
        let dks = dkg.dist_key_share().is_err();

        assert!(dks);

        let deals = dkg.deals().unwrap();

        assert_eq!(deals.len(), (participants_count - 1) as usize);

        for (_, deal) in deals.iter() {
            assert_eq!(0, deal.index);
        }

        let v = dkg.verifiers.get(&dkg.index);
        assert!(v.is_some());
    }

    #[test]
    fn test_dkg_process_deal() {
        let participants_count: u32 = 7;
        let mut init_data = setup(participants_count);
        let dkg: &mut DistKeyGenerator = init_data.dkgs.get_mut(0 as usize).unwrap();
        let deals = dkg.deals().unwrap();

        let rec: &mut DistKeyGenerator = init_data.dkgs.get_mut(1 as usize).unwrap();
        let mut deal: Deal = deals.get(&1).unwrap().clone();

        assert_eq!(0, deal.index);
        assert_eq!(1, rec.index);

        // verifier don't find itself
        let correct_p: Vec<GE> = rec.participants.clone();
        rec.participants = Vec::new();
        let resp = rec.process_deal(&deal).is_err();

        assert!(resp);

        rec.participants = correct_p;

        // good deal
        let resp = rec.process_deal(&deal).unwrap();

        assert!(resp.response.approved);

        let verif = rec.verifiers.get(&deal.index);

        assert!(verif.is_some());
        assert_eq!(0, resp.index);

        // duplicate
        let resp = rec.process_deal(&deal);

        assert!(resp.is_err());

        // wrong index
        let correct_idx: u32 = deal.index;
        deal.index = participants_count + 1;
        let resp = rec.process_deal(&deal);

        assert!(resp.is_err());

        deal.index = correct_idx;

        // wrong deal
        deal.deal.signature = custom_signature();
        let resp = rec.process_deal(&deal);

        assert!(resp.is_err());
    }

    #[test]
    fn test_dkg_process_response() {
        let participants_count: u32 = 7;
        let init_data = setup(participants_count);

        let mut dkg: DistKeyGenerator = init_data.dkgs[0 as usize].clone();
        let idx_rec: u32 = 1;
        let mut rec: DistKeyGenerator = init_data.dkgs[idx_rec as usize].clone();

        // give a wrong deal
        let correct_secret: FE = dkg.dealer.deals[idx_rec as usize].rnd_share.v;
        dkg.dealer.deals[idx_rec as usize].rnd_share.v = ECScalar::zero();
        let dd = dkg.deals().unwrap();
        let enc_d: &Deal = dd.get(&idx_rec).unwrap();
        let mut resp: Response = rec.process_deal(enc_d).unwrap();

        assert!(!resp.response.approved);

        dkg.dealer.deals[idx_rec as usize].rnd_share.v = correct_secret;

        // no verifier tied to Response
        let v: vssVerifier = dkg.verifiers.get(&0).unwrap().clone();
        dkg.verifiers.remove(&0);
        let j = dkg.process_response(&resp);

        assert!(j.is_err());

        dkg.verifiers.insert(0, v);

        // invalid response
        let correct_sig: Vec<u8> = resp.response.signature.clone();
        resp.response.signature = custom_signature();
        let j = dkg.process_response(&resp);

        assert!(j.is_err());

        resp.response.signature = correct_sig;

        // valid complaint from our deal
        dkg.process_response(&resp).unwrap();

        // valid complaint from another deal from another peer
        let mut dkg2: DistKeyGenerator = init_data.dkgs[2].clone();
        let correct_secret: FE = dkg2.dealer.deals[idx_rec as usize].rnd_share.v;
        dkg2.dealer.deals[idx_rec as usize].rnd_share.v = ECScalar::zero();
        let deals2 = dkg2.deals().unwrap();

        let deal12: &Deal = deals2.get(&idx_rec).unwrap();
        let mut resp12: Response = rec.process_deal(deal12).unwrap();

        assert!(!resp12.response.approved);

        dkg2.dealer.deals[idx_rec as usize].rnd_share.v = correct_secret;
        let deals2 = dkg2.deals().unwrap();

        // give it to the first peer
        // process dealer 2's deal
        let deal2: &Deal = deals2.get(&0).unwrap();
        dkg.process_deal(deal2).unwrap();

        // process response from peer 1
        let j = dkg.process_response(&resp12).unwrap();

        assert!(j.is_none());

        // Justification part:
        // give the complaint to the dealer
        let j = dkg2.process_response(&resp12).unwrap();

        assert!(j.is_some());

        let j: Justification = j.unwrap();

        resp12.response.approved = false;
        dkg.process_justification(&j).unwrap();

        // remove verifiers
        dkg.verifiers.remove(&0);
        let err = dkg.process_justification(&j);

        assert!(err.is_err());
    }

    #[test]
    fn test_dkg_secret_commits() {
        let participants_count: u32 = 7;
        let init_data = setup(participants_count);

        let mut dkgs: Vec<DistKeyGenerator> = init_data.dkgs;
        full_exchange(&mut dkgs, participants_count);

        let mut dkg: DistKeyGenerator = dkgs[0].clone();

        let mut sc: SecretCommits = dkg.secret_commits().unwrap();
        let msg: [u8; 32] = SecretCommits::hash(&sc.commitments, sc.index).unwrap();

        sign::verify_signature(
            dkg.pub_key.get_element().to_bytes().as_ref(),
            sc.signature.as_ref(),
            msg.as_ref(),
            sc.index.to_le_bytes().as_ref(),
        )
        .expect("Signature must be valid");

        // wrong index
        let mut dkg2: DistKeyGenerator = dkgs.get(1 as usize).unwrap().clone();
        let correct_idx: u32 = sc.index;
        sc.index = participants_count + 1;
        let cc = dkg2.process_secret_commit(&sc);

        assert!(cc.is_err());

        sc.index = correct_idx;

        // not in qual: delete the verifier
        let correct_v = dkg2.verifiers.get(&0).unwrap().clone();
        dkg2.verifiers.remove(&0);
        let cc = dkg2.process_secret_commit(&sc);

        assert!(cc.is_err());

        dkg2.verifiers.insert(0, correct_v);

        // invalid sig
        let correct_sig: Vec<u8> = sc.signature.clone();
        sc.signature = custom_signature();
        let cc = dkg2.process_secret_commit(&sc);

        assert!(cc.is_err());

        sc.signature = correct_sig;

        // invalid session id
        let correct_sid: Vec<u8> = sc.session_id.clone();
        sc.session_id = [0u8; 32].to_vec();
        let cc = dkg2.process_secret_commit(&sc);

        assert!(cc.is_err());

        sc.session_id = correct_sid;

        // wrong commitments
        let correct_point: Vec<u8> = sc.commitments.get(0 as usize).unwrap().clone();
        let generator = GE::generator();
        sc.commitments.remove(0 as usize);
        sc.commitments
            .insert(0 as usize, generator.get_element().to_bytes().to_vec());
        let msg: [u8; 32] = SecretCommits::hash(&sc.commitments, sc.index).unwrap();
        let signature = sign::sign_msg(
            dkg.long.get_element().to_bytes(),
            dkg.pub_key.get_element().to_bytes(),
            &msg,
            &sc.index.to_le_bytes(),
        )
        .unwrap();
        let correct_sig: Vec<u8> = sc.signature.clone();
        sc.signature = signature;
        let cc = dkg2.process_secret_commit(&sc);

        assert!(cc.is_ok());

        sc.commitments.remove(0 as usize);
        sc.commitments.insert(0 as usize, correct_point);
        sc.signature = correct_sig;

        // all fine
        let cc = dkg2.process_secret_commit(&sc);

        assert!(cc.is_ok());
    }

    #[test]
    fn test_dkg_complaint_commits() {
        let participants_count: u32 = 7;
        let init_data = setup(participants_count);

        let mut dkgs: Vec<DistKeyGenerator> = init_data.dkgs;
        full_exchange(&mut dkgs, participants_count);

        let mut scs: Vec<SecretCommits> = Vec::new();

        for ind in 0..dkgs.len() {
            let dkg: &mut DistKeyGenerator = dkgs.get_mut(ind as usize).unwrap();
            let sc: SecretCommits = dkg.secret_commits().unwrap();
            scs.push(sc);
        }

        for sc in scs.iter() {
            for ind in 0..dkgs.len() {
                let dkg: &mut DistKeyGenerator = dkgs.get_mut(ind as usize).unwrap();
                dkg.process_secret_commit(sc).unwrap();
            }
        }

        // change the sc for the second one
        let mut commits: Vec<Vec<u8>> = scs.get(0 as usize).unwrap().commitments.clone();
        let generator = GE::generator();
        commits.remove(0 as usize);
        commits.insert(0 as usize, generator.get_element().to_bytes().to_vec());
        let msg: [u8; 32] = SecretCommits::hash(&commits, scs[0].index).unwrap();
        let temp_dkg: DistKeyGenerator = dkgs.get(0 as usize).unwrap().clone();
        let signature = sign::sign_msg(
            temp_dkg.long.get_element().to_bytes(),
            temp_dkg.pub_key.get_element().to_bytes(),
            &msg,
            &scs.get(0 as usize).unwrap().index.to_le_bytes(),
        )
        .unwrap();
        let wrong_sc = SecretCommits {
            index: scs.get(0 as usize).unwrap().index,
            commitments: commits,
            session_id: scs.get(0 as usize).unwrap().session_id.clone(),
            signature,
        };

        let mut dkg: DistKeyGenerator = dkgs.get(1 as usize).unwrap().clone();
        let mut cc: ComplaintCommits = dkg.process_secret_commit(&wrong_sc).unwrap().unwrap();

        // ComplaintCommits: wrong index
        let mut dkg2: DistKeyGenerator = dkgs.get(2 as usize).unwrap().clone();
        let correct_index = cc.index;
        cc.index = participants_count;
        let rc = dkg2.process_complaints_commits(&cc);

        assert!(rc.is_err());

        cc.index = correct_index;

        // invalid signature
        let correct_sig = cc.signature.clone();
        cc.signature = custom_signature();
        let rc = dkg2.process_complaints_commits(&cc);

        assert!(rc.is_err());

        cc.signature = correct_sig;

        // no verifiers
        let v = dkg2.verifiers.get(&0).unwrap().clone();
        dkg2.verifiers.remove(&0);
        let rc = dkg2.process_complaints_commits(&cc);

        assert!(rc.is_err());

        dkg2.verifiers.insert(0, v);

        // deal does not verify
        let rc = dkg2.process_complaints_commits(&cc);

        assert!(rc.is_err());

        // no commitments
        let sc = dkg2.commitments.get(&0).unwrap().clone();
        dkg2.commitments.remove(&0);
        let rc = dkg2.process_complaints_commits(&cc);

        assert!(rc.is_err());

        dkg2.commitments.insert(0, sc);

        // secret commits are passing the check
        let rc = dkg2.process_complaints_commits(&cc);

        assert!(rc.is_err());
    }

    #[test]
    fn test_dkg_reconstruct_commits() {
        let participants_count: u32 = 7;
        let init_data = setup(participants_count);

        let mut dkgs: Vec<DistKeyGenerator> = init_data.dkgs;
        full_exchange(&mut dkgs, participants_count);

        let mut scs: Vec<SecretCommits> = Vec::new();

        for ind in 0..dkgs.len() {
            let dkg: &mut DistKeyGenerator = dkgs.get_mut(ind as usize).unwrap();
            let sc: SecretCommits = dkg.secret_commits().unwrap();
            scs.push(sc);
        }

        for sc in scs.iter() {
            for ind in 2..dkgs.len() {
                let dkg: &mut DistKeyGenerator = dkgs.get_mut(ind as usize).unwrap();
                dkg.process_secret_commit(sc).unwrap();
            }
        }

        // peer 1 wants to reconstruct coeffs from dealer 1
        let mut temp_dkg: DistKeyGenerator = dkgs.get(1 as usize).unwrap().clone();
        let share: vssDeal = temp_dkg.verifiers.get_mut(&0).unwrap().get_deal().unwrap();
        let msg = ReconstructCommits::hash(1, 0, &share.sec_share).unwrap();
        let signature = sign::sign_msg(
            temp_dkg.long.get_element().to_bytes(),
            temp_dkg.pub_key.get_element().to_bytes(),
            &msg,
            &temp_dkg.index.to_le_bytes(),
        )
        .unwrap();
        let mut rc = ReconstructCommits {
            session_id: share.session_id.clone(),
            index: 1,
            dealer_index: 0,
            share: share.sec_share,
            signature,
        };

        // reconstructed already set
        let mut dkg2: DistKeyGenerator = dkgs.get(2 as usize).unwrap().clone();
        dkg2.reconstructed.insert(0);
        let reconstr = dkg2.process_reconstruct_commits(&rc);

        assert!(reconstr.is_ok());

        dkg2.reconstructed.remove(&0);

        // commitments not invalidated by any comlaints
        let reconstr = dkg2.process_reconstruct_commits(&rc);

        assert!(reconstr.is_err());

        dkg2.commitments.remove(&0);

        // invalid index
        let correct_ind = rc.index;
        rc.index = participants_count;
        let reconstr = dkg2.process_reconstruct_commits(&rc);

        assert!(reconstr.is_err());

        rc.index = correct_ind;

        // invalid sig
        let correct_sig = rc.signature;
        rc.signature = custom_signature();
        let reconstr = dkg2.process_reconstruct_commits(&rc);

        assert!(reconstr.is_err());

        rc.signature = correct_sig;

        // all fine
        let reconstr = dkg2.process_reconstruct_commits(&rc);

        assert!(reconstr.is_ok());

        // packet already received
        let mut found: bool = false;
        for p in dkg2
            .pending_reconstruct
            .get(&rc.dealer_index)
            .unwrap()
            .iter()
        {
            if p.index == rc.index {
                found = true;
                break;
            }
        }

        assert!(found);
        assert!(!dkg2.finished());

        // generate enough secret commits to recover the secret
        for ind in 2..dkgs.len() {
            let dkg: &mut DistKeyGenerator = dkgs.get_mut(ind as usize).unwrap();
            let share: vssDeal = dkg.verifiers.get_mut(&0).unwrap().get_deal().unwrap();
            let msg = ReconstructCommits::hash(dkg.index, 0, &share.sec_share).unwrap();
            let signature = sign::sign_msg(
                dkg.long.get_element().to_bytes(),
                dkg.pub_key.get_element().to_bytes(),
                &msg,
                &dkg.index.to_le_bytes(),
            )
            .unwrap();
            let mut rc = ReconstructCommits {
                session_id: share.session_id.clone(),
                index: dkg.index,
                dealer_index: 0,
                share: share.sec_share.clone(),
                signature,
            };

            if dkg2.reconstructed.contains(&0) {
                break;
            }

            let correct_sid = rc.session_id;
            rc.session_id = [0u8; 32].to_vec();
            dkg2.process_reconstruct_commits(&rc)
                .expect_err("Invalid session ID");

            rc.session_id = correct_sid;

            dkg2.process_reconstruct_commits(&rc).unwrap();
        }

        assert!(dkg2.reconstructed.contains(&0));

        let com: &PubPoly = dkg2.commitments.get(&0).unwrap();

        let dkg = dkgs.get_mut(0).unwrap();

        assert_eq!(dkg.dealer.secret_commit().unwrap(), com.commit());

        assert!(dkg2.finished());
    }

    #[test]
    fn test_dkg_set_timeout() {
        let participants_count: u32 = 7;
        let init_data = setup(participants_count);

        let mut dkgs: Vec<DistKeyGenerator> = init_data.dkgs;

        // full secret sharing exchange
        // 1. broadcast deals
        let mut resps: Vec<Response> = Vec::new();
        for dkg_ind in 0..dkgs.len() {
            let deals = dkgs[dkg_ind].deals().unwrap();
            for (&i, deal) in deals.iter() {
                let resp: Response = dkgs[i as usize].process_deal(deal).unwrap();

                assert!(resp.response.approved);

                resps.push(resp);
            }
        }
        // 2. broadcast response
        for r in resps.iter() {
            for dkg in dkgs.iter_mut() {
                if !dkg.verifiers.get(&r.index).unwrap().enough_approvals()
                    && r.response.index != dkg.index
                {
                    let j = dkg.process_response(r).unwrap();

                    assert!(j.is_none());
                }
            }
        }
        // 3. make sure everyone has the same QUAL set
        for dkg in dkgs.iter() {
            for dkg2 in dkgs.iter() {
                assert!(!dkg.is_in_qual(dkg2.index));
            }
        }

        for dkg in dkgs.iter_mut() {
            dkg.set_timeout();
        }

        for dkg in dkgs.iter() {
            for dkg1 in dkgs.iter() {
                assert!(dkg.is_in_qual(dkg1.index));
            }
        }
    }

    #[test]
    fn test_dkg_dist_key_share() {
        let participants_count: u32 = 7;
        let init_data = setup(participants_count);

        let mut dkgs: Vec<DistKeyGenerator> = init_data.dkgs;
        full_exchange(&mut dkgs, participants_count);

        let mut scs: Vec<SecretCommits> = Vec::new();

        for ind in 0..participants_count as usize - 1 {
            let sc: SecretCommits = dkgs[ind].secret_commits().unwrap();
            #[allow(clippy::needless_range_loop)]
            for ind2 in 0..participants_count as usize - 1 {
                if ind == ind2 {
                    continue;
                }
                let cc = dkgs[ind2].process_secret_commit(&sc).unwrap();

                assert!(cc.is_none());
            }
            scs.push(sc);
        }

        // check that we can't get the dist key share before exchanging commitments
        let mut last_dkg: DistKeyGenerator =
            dkgs.get((participants_count - 1) as usize).unwrap().clone();
        last_dkg
            .dist_key_share()
            .expect_err("Didn't exchange committments yet");

        for sc in scs.iter() {
            let cc = last_dkg.process_secret_commit(sc).unwrap();

            assert!(cc.is_none());
        }

        let sc: SecretCommits = last_dkg.secret_commits().unwrap();

        for dkg in dkgs.iter_mut().take(participants_count as usize - 1) {
            let sc = dkg.process_secret_commit(&sc).unwrap();

            assert!(sc.is_none());
            assert_eq!(participants_count, dkg.qual().len() as u32);
            assert_eq!(participants_count, dkg.commitments.len() as u32);
        }

        // missing one commitment
        let last_commitment0 = last_dkg.commitments.get(&0).unwrap().clone();
        last_dkg.commitments.remove(&0);
        let dks = last_dkg.dist_key_share();

        assert!(dks.is_err());

        last_dkg.commitments.insert(0, last_commitment0);

        dkgs.remove((participants_count - 1) as usize);
        dkgs.insert((participants_count - 1) as usize, last_dkg);

        // everyone should be finished
        for dkg in dkgs.iter_mut() {
            assert!(dkg.finished());
        }
        // verify integrity of shares etc
        let mut dkss: Vec<DistKeyShare> = Vec::new();
        for dkg in dkgs.iter_mut() {
            let dks: DistKeyShare = dkg.dist_key_share().unwrap();
            assert_eq!(dkg.index, dks.share.i);

            dkss.push(dks);
        }

        let mut shares: Vec<PriShare<FE>> = Vec::new();
        for dks in dkss.iter() {
            assert!(check_dks(dks, dkss.get(0 as usize).unwrap()));
            shares.push(dks.share.clone());
        }

        let secret = poly::recover_secret(&shares.as_slice(), participants_count / 2 + 1).unwrap();

        let generator = GE::generator();
        let commit_secret = generator.scalar_mul(&secret.get_element());

        assert_eq!(
            dkss.get(0 as usize).unwrap().get_public_key(),
            commit_secret
        );
    }

    fn check_dks(dks1: &DistKeyShare, dks2: &DistKeyShare) -> bool {
        if dks1.commits.len() != dks2.commits.len() {
            return false;
        }
        for (i, p) in dks1.commits.iter().enumerate() {
            if p != dks2.commits.get(i).unwrap() {
                return false;
            }
        }
        true
    }
}
