//! Distributed key generation (DKG) is a cryptographic process in which multiple
//! parties contribute to the calculation of a shared public and private key set.

use std::collections::{HashMap, HashSet};
use std::convert::TryInto;
use std::error::Error;
use std::io::Write;

use crate::curve_traits;
use crate::poly;
use crate::ristretto_curve;
use crate::sign;
use crate::utils;
use crate::vss;

use curve_traits::{ECPoint, ECScalar};
use ristretto_curve::{FE, GE};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

use poly::PriPoly;
use poly::PriShare;
use poly::PubPoly;
use utils::bitwise_eq;
use vss::Deal as vssDeal;
use vss::Dealer;
use vss::EncryptedDeal;
use vss::Justification as vssJustification;
use vss::Response as vssResponce;
use vss::Verifier as vssVerifier;

/// DistKeyShare holds the share of a distributed key for a participant.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DistKeyShare {
    // Coefficients of the public polynomial holding the public key
    commits: Vec<GE>,
    // Share of the distributed secret
    share: PriShare<FE>,
}

/// Deal holds the Deal for one participant as well as the index of the issuing
/// Dealer.
/// NOTE: Doing that in vss.rs would be possible but then the Dealer is always
/// assumed to be a member of the participants. It's only the case here.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Deal {
    // Index of the Dealer in the list of participants
    pub index: u32,
    // Deal issued for another participant
    pub deal: EncryptedDeal,
}

/// Response holds the Response from another participant as well as the index of
/// the target Dealer.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Response {
    // Index of the Dealer for which this response is for
    pub index: u32,
    // Response issued from another participant
    pub response: vssResponce,
}

/// Justification holds the Justification from a Dealer as well as the index of
/// the Dealer in question.
#[derive(Serialize, Deserialize, Clone)]
pub struct Justification {
    // Index of the Dealer who answered with this Justification
    pub index: u32,
    // Justification issued from the Dealer
    pub justification: vssJustification,
}

/// SecretCommits is sent during the distributed public key reconstruction phase,
/// basically a Feldman VSS scheme.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SecretCommits {
    // Index of the Dealer in the list of participants
    pub index: u32,
    // Commitments generated by the Dealer
    pub commitments: Vec<Vec<u8>>,
    // SessionID generated by the Dealer tied to the Deal
    pub session_id: Vec<u8>,
    // Signature from the Dealer
    pub signature: Vec<u8>,
}

/// ComplaintCommits is sent if the secret commitments revealed by a peer are not
/// valid.
#[derive(Serialize, Deserialize)]
pub struct ComplaintCommits {
    // Index of the Verifier _issuing_ the ComplaintCommit
    pub index: u32,
    // DealerIndex being the index of the Dealer who issued the SecretCommits
    pub dealer_index: u32,
    // Deal that has been given from the Dealer (at DealerIndex) to this node
    // (at Index)
    pub deal: vssDeal,
    // Signature made by the verifier
    pub signature: Vec<u8>,
}

/// ReconstructCommits holds the information given by a participant who reveals
/// the deal received from a peer that has received a ComplaintCommits.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ReconstructCommits {
    // Id of the session
    session_id: Vec<u8>,
    // Index of the verifier who received the deal
    index: u32,
    // DealerIndex is the index of the dealer who issued the Deal
    dealer_index: u32,
    // Share contained in the Deal
    share: PriShare<FE>,
    // Signature over all over fields generated by the issuing verifier
    signature: Vec<u8>,
}

/// DistKeyGenerator is the struct that runs the DKG protocol.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DistKeyGenerator {
    // Index of participant in the DKG protocol
    index: u32,
    // longterm secret, i.e. private key of the node
    long: FE,
    // longterm public key
    pub_key: GE,
    // pub keys of all the participants
    participants: Vec<GE>,
    // threshold
    t: u32,
    // vss dealer, to distribute secret committments
    dealer: Dealer,
    // verifiers to process deals from DKG with index i
    verifiers: HashMap<u32, vssVerifier>,
    // list of commitments to each secret polynomial
    commitments: HashMap<u32, PubPoly>,

    // Map of deals collected to reconstruct the full polynomial of a dealer.
    // The key is index of the dealer. Once there are enough ReconstructCommits
    // struct, this dkg will re-construct the polynomial and stores it into the
    // list of commitments.
    pending_reconstruct: HashMap<u32, Vec<ReconstructCommits>>,
    reconstructed: HashSet<u32>,
    sig_ctx: Vec<u8>,
}

impl DistKeyGenerator {
    /// longterm: the secret (private) key,
    /// participants: the list of participants pubkeys,
    /// t: threshold parameter
    ///
    /// It returns an error if the secret key's commitment can't
    /// be found in the list of participants.
    pub fn new(
        longterm: FE,
        participants: Vec<GE>,
        t: u32,
    ) -> Result<DistKeyGenerator, Box<dyn Error>> {
        let generator = GE::generator();
        let pub_k: GE = generator.scalar_mul(&longterm.get_element());

        let index = participants
            .iter()
            .position(|point| point == &pub_k)
            .ok_or_else(|| {
                simple_error!("dkg: own public key not found in list of participants")
            })?;

        // generate our dealer
        let own_secret = FE::new_random();
        let dealer = Dealer::new(longterm, own_secret, participants.clone(), t)?;

        Ok(DistKeyGenerator {
            index: index as u32,
            long: longterm,
            pub_key: pub_k,
            participants,
            t,
            dealer,
            verifiers: Default::default(),
            commitments: Default::default(),
            pending_reconstruct: Default::default(),
            reconstructed: Default::default(),
            sig_ctx: index.to_le_bytes().to_vec(),
        })
    }

    /// deals returns all the deals that must be broadcasted to all
    /// participants. The deal corresponding to this DKG is already added
    /// to this DKG and is omitted from the returned map. To know
    /// to which participant a deal belongs to, loop over the keys as indices in
    /// the list of participants.
    pub fn deals(&mut self) -> Result<HashMap<u32, Deal>, Box<dyn Error>> {
        let deals: Vec<EncryptedDeal> = self.dealer.encrypt_deals()?;

        debug_assert!(deals.len() == self.participants.len());

        let mut dist_deals: HashMap<u32, Deal> = HashMap::new();
        for (i, deal) in deals.into_iter().enumerate() {
            let dist_d = Deal {
                index: self.index,
                deal,
            };
            if i as u32 == self.index {
                if self.verifiers.contains_key(&self.index) {
                    // already processed our own deal
                    continue;
                }
                let resp: Response = self.process_deal(&dist_d)?;
                if !resp.response.approved {
                    bail!("dkg: own deal gave a complaint")
                }

                // If processed own deal correctly, set positive response in this
                // DKG's dealer's own verifier
                self.dealer.unsafe_set_response_dkg(self.index, true)?;
            } else {
                dist_deals.insert(i as u32, dist_d);
            }
        }

        Ok(dist_deals)
    }

    /// process_deal takes a Deal created by deals() and stores and verifies it. It
    /// returns a Response to broadcast to every other participants. It returns an
    /// error in case the deal has already been stored, or if the deal is incorrect
    pub fn process_deal(&mut self, dd: &Deal) -> Result<Response, Box<dyn Error>> {
        // public key of the dealer
        let pub_k = self
            .participants
            .get(dd.index as usize)
            .ok_or_else(|| simple_error!("dkg: dist deal out of bounds index"))?;

        if self.verifiers.contains_key(&dd.index) {
            bail!("dkg: already received dist deal from same index");
        }

        // verifier receiving the dealer's deal
        let mut ver: vssVerifier = vssVerifier::new(self.long, *pub_k, self.participants.clone())?;
        let resp: vssResponce = ver.process_encrypted_deal(&dd.deal)?;

        // Set status_approval for the verifier that represents the participant
        // that distributed the Deal
        // We shouldn't check result here such as call unsafe bypass method
        ver.unsafe_set_response_dkg(dd.index, true)
            .unwrap_or_default();

        self.verifiers.insert(dd.index, ver);

        Ok(Response {
            index: dd.index,
            response: resp,
        })
    }
}