//! Distributed key generation (DKG) is a cryptographic process in which multiple
//! parties contribute to the calculation of a shared public and private key set.

use std::collections::{HashMap, HashSet};
use std::convert::TryInto;
use std::error::Error;
use std::io::Write;

use crate::curve_traits;
use crate::poly;
use crate::ristretto_curve;
use crate::sign;
use crate::utils;
use crate::vss;

use curve_traits::{ECPoint, ECScalar};
use ristretto_curve::{FE, GE};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

use poly::PriPoly;
use poly::PriShare;
use poly::PubPoly;
use utils::bitwise_eq;
use vss::Deal as vssDeal;
use vss::Dealer;
use vss::EncryptedDeal;
use vss::Justification as vssJustification;
use vss::Response as vssResponce;
use vss::Verifier as vssVerifier;

/// DistKeyShare holds the share of a distributed key for a participant.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DistKeyShare {
    // Coefficients of the public polynomial holding the public key
    commits: Vec<GE>,
    // Share of the distributed secret
    share: PriShare<FE>,
}

/// Deal holds the Deal for one participant as well as the index of the issuing
/// Dealer.
/// NOTE: Doing that in vss.rs would be possible but then the Dealer is always
/// assumed to be a member of the participants. It's only the case here.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Deal {
    // Index of the Dealer in the list of participants
    pub index: u32,
    // Deal issued for another participant
    pub deal: EncryptedDeal,
}

/// Response holds the Response from another participant as well as the index of
/// the target Dealer.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Response {
    // Index of the Dealer for which this response is for
    pub index: u32,
    // Response issued from another participant
    pub response: vssResponce,
}

/// Justification holds the Justification from a Dealer as well as the index of
/// the Dealer in question.
#[derive(Serialize, Deserialize, Clone)]
pub struct Justification {
    // Index of the Dealer who answered with this Justification
    pub index: u32,
    // Justification issued from the Dealer
    pub justification: vssJustification,
}

/// SecretCommits is sent during the distributed public key reconstruction phase,
/// basically a Feldman VSS scheme.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SecretCommits {
    // Index of the Dealer in the list of participants
    pub index: u32,
    // Commitments generated by the Dealer
    pub commitments: Vec<Vec<u8>>,
    // SessionID generated by the Dealer tied to the Deal
    pub session_id: Vec<u8>,
    // Signature from the Dealer
    pub signature: Vec<u8>,
}

/// ComplaintCommits is sent if the secret commitments revealed by a peer are not
/// valid.
#[derive(Serialize, Deserialize)]
pub struct ComplaintCommits {
    // Index of the Verifier _issuing_ the ComplaintCommit
    pub index: u32,
    // DealerIndex being the index of the Dealer who issued the SecretCommits
    pub dealer_index: u32,
    // Deal that has been given from the Dealer (at DealerIndex) to this node
    // (at Index)
    pub deal: vssDeal,
    // Signature made by the verifier
    pub signature: Vec<u8>,
}

/// ReconstructCommits holds the information given by a participant who reveals
/// the deal received from a peer that has received a ComplaintCommits.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ReconstructCommits {
    // Id of the session
    session_id: Vec<u8>,
    // Index of the verifier who received the deal
    index: u32,
    // DealerIndex is the index of the dealer who issued the Deal
    dealer_index: u32,
    // Share contained in the Deal
    share: PriShare<FE>,
    // Signature over all over fields generated by the issuing verifier
    signature: Vec<u8>,
}

/// DistKeyGenerator is the struct that runs the DKG protocol.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DistKeyGenerator {
    // Index of participant in the DKG protocol
    index: u32,
    // longterm secret, i.e. private key of the node
    long: FE,
    // longterm public key
    pub_key: GE,
    // pub keys of all the participants
    participants: Vec<GE>,
    // threshold
    t: u32,
    // vss dealer, to distribute secret committments
    dealer: Dealer,
    // verifiers to process deals from DKG with index i
    verifiers: HashMap<u32, vssVerifier>,
    // list of commitments to each secret polynomial
    commitments: HashMap<u32, PubPoly>,

    // Map of deals collected to reconstruct the full polynomial of a dealer.
    // The key is index of the dealer. Once there are enough ReconstructCommits
    // struct, this dkg will re-construct the polynomial and stores it into the
    // list of commitments.
    pending_reconstruct: HashMap<u32, Vec<ReconstructCommits>>,
    reconstructed: HashSet<u32>,
    sig_ctx: Vec<u8>,
}

impl DistKeyGenerator {
    /// longterm: the secret (private) key,
    /// participants: the list of participants pubkeys,
    /// t: threshold parameter
    ///
    /// It returns an error if the secret key's commitment can't
    /// be found in the list of participants.
    pub fn new(
        longterm: FE,
        participants: Vec<GE>,
        t: u32,
    ) -> Result<DistKeyGenerator, Box<dyn Error>> {
        let generator = GE::generator();
        let pub_k: GE = generator.scalar_mul(&longterm.get_element());

        let index = participants
            .iter()
            .position(|point| point == &pub_k)
            .ok_or_else(|| {
                simple_error!("dkg: own public key not found in list of participants")
            })?;

        // generate our dealer
        let own_secret = FE::new_random();
        let dealer = Dealer::new(longterm, own_secret, participants.clone(), t)?;

        Ok(DistKeyGenerator {
            index: index as u32,
            long: longterm,
            pub_key: pub_k,
            participants,
            t,
            dealer,
            verifiers: Default::default(),
            commitments: Default::default(),
            pending_reconstruct: Default::default(),
            reconstructed: Default::default(),
            sig_ctx: index.to_le_bytes().to_vec(),
        })
    }

    /// deals returns all the deals that must be broadcasted to all
    /// participants. The deal corresponding to this DKG is already added
    /// to this DKG and is omitted from the returned map. To know
    /// to which participant a deal belongs to, loop over the keys as indices in
    /// the list of participants.
    pub fn deals(&mut self) -> Result<HashMap<u32, Deal>, Box<dyn Error>> {
        let deals: Vec<EncryptedDeal> = self.dealer.encrypt_deals()?;

        debug_assert!(deals.len() == self.participants.len());

        let mut dist_deals: HashMap<u32, Deal> = HashMap::new();
        for (i, deal) in deals.into_iter().enumerate() {
            let dist_d = Deal {
                index: self.index,
                deal,
            };
            if i as u32 == self.index {
                if self.verifiers.contains_key(&self.index) {
                    // already processed our own deal
                    continue;
                }
                let resp: Response = self.process_deal(&dist_d)?;
                if !resp.response.approved {
                    bail!("dkg: own deal gave a complaint")
                }

                // If processed own deal correctly, set positive response in this
                // DKG's dealer's own verifier
                self.dealer.unsafe_set_response_dkg(self.index, true)?;
            } else {
                dist_deals.insert(i as u32, dist_d);
            }
        }

        Ok(dist_deals)
    }

    /// process_deal takes a Deal created by deals() and stores and verifies it. It
    /// returns a Response to broadcast to every other participants. It returns an
    /// error in case the deal has already been stored, or if the deal is incorrect
    pub fn process_deal(&mut self, dd: &Deal) -> Result<Response, Box<dyn Error>> {
        // public key of the dealer
        let pub_k = self
            .participants
            .get(dd.index as usize)
            .ok_or_else(|| simple_error!("dkg: dist deal out of bounds index"))?;

        if self.verifiers.contains_key(&dd.index) {
            bail!("dkg: already received dist deal from same index");
        }

        // verifier receiving the dealer's deal
        let mut ver: vssVerifier = vssVerifier::new(self.long, *pub_k, self.participants.clone())?;
        let resp: vssResponce = ver.process_encrypted_deal(&dd.deal)?;

        // Set status_approval for the verifier that represents the participant
        // that distributed the Deal
        // We shouldn't check result here such as call unsafe bypass method
        ver.unsafe_set_response_dkg(dd.index, true)
            .unwrap_or_default();

        self.verifiers.insert(dd.index, ver);

        Ok(Response {
            index: dd.index,
            response: resp,
        })
    }

    /// process_response takes a response from every other peer. If the response
    /// designates the deal of another participants than this dkg, this dkg stores it
    /// and returns None or a possible error regarding the validity of the response.
    /// If the response designates a deal this dkg has issued, then the dkg will process
    /// the response, and returns a justification.
    pub fn process_response(
        &mut self,
        resp: &Response,
    ) -> Result<Option<Justification>, Box<dyn Error>> {
        let v: &mut vssVerifier = self
            .verifiers
            .get_mut(&resp.index)
            .ok_or_else(|| simple_error!("dkg: complaint received but no deal for it"))?;

        v.process_response(&resp.response)?;

        if resp.index != self.index {
            return Ok(None);
        }

        match self.dealer.process_response(&resp.response)? {
            Some(justification) => {
                // a justification for our own deal
                v.process_justification(&justification)?;

                Ok(Some(Justification {
                    index: self.index,
                    justification,
                }))
            }
            None => Ok(None),
        }
    }

    /// process_justification takes a justification and validates it. It returns an
    /// error in case the justification is wrong.
    pub fn process_justification(&mut self, j: &Justification) -> Result<(), Box<dyn Error>> {
        self.verifiers
            .get_mut(&j.index)
            .ok_or_else(|| simple_error!("dkg: Justification received but no deal for it"))?
            .process_justification(&j.justification)
    }

    /// set_timeout triggers the timeout on all verifiers, and thus makes sure
    /// all verifiers have either responded, or have a StatusComplaint response.
    pub fn set_timeout(&mut self) {
        for v in self.verifiers.values_mut() {
            v.set_timeout();
        }
    }

    /// certified returns true if at least t deals are certified (see
    /// vss.Verifier.deal_certified()). If the distribution is certified, the protocol
    /// can continue using d.SecretCommits().
    pub fn certified(&self) -> bool {
        self.qual().len() as u32 >= self.t
    }

    /// qual returns the index in the list of participants that forms the qualified
    /// set as described in the "New-DKG" protocol by Rabin. Basically, it consists
    /// of all participants that are not disqualified after having exchanged all
    /// deals, responses and justification. This is the set that is used to extract
    /// the distributed public key with secret_commits() and process_secret_commits().
    pub fn qual(&self) -> Vec<u32> {
        self.verifiers
            .iter()
            .filter(|(_, v)| v.deal_certified())
            .map(|(&i, _)| i)
            .collect()
    }

    /// Checks if verifier with idx is in qualified set
    pub fn is_in_qual(&self, idx: u32) -> bool {
        self.verifiers
            .get(&idx)
            .map(vssVerifier::deal_certified)
            .unwrap_or(false)
    }

    /// secret_commits returns the commitments of the coefficients of the secret
    /// polynomials. This secret commits must be broadcasted to every other
    /// participant and must be processed by process_secret_commits. In this manner,
    /// the coefficients are revealed through a Feldman VSS scheme.
    /// This dkg must have its deal certified, otherwise it returns an error. The
    /// secret_commits returned is already added to this dkg's list of secret_commits.
    pub fn secret_commits(&mut self) -> Result<SecretCommits, Box<dyn Error>> {
        if !self.dealer.deal_certified() {
            bail!("dkg: can't give SecretCommits if deal not certified");
        }
        let commits: Vec<Vec<u8>> = self.dealer.commits().unwrap();
        let session_id: Vec<u8> = self.dealer.get_session_id().to_vec();
        let msg: [u8; 32] = SecretCommits::hash(&commits, self.index)?;
        let signature = sign::sign_msg(
            self.long.get_element().to_bytes(),
            self.pub_key.get_element().to_bytes(),
            &msg,
            &self.index.to_le_bytes(),
        )?;
        let sc = SecretCommits {
            index: self.index,
            commitments: commits.clone(),
            session_id,
            signature,
        };
        // adding our own commitments
        let commits_p = commits
            .iter()
            .map(|c| GE::from_bytes(&c))
            .collect::<Result<Vec<_>, _>>()
            .unwrap();
        self.commitments.insert(
            self.index,
            poly::PubPoly::new(ECPoint::generator(), commits_p),
        );
        Ok(sc)
    }

    /// process_secret_commit takes a SecretCommits from every other participant and
    /// verifies and stores it. It returns an error in case the SecretCommits is
    /// invalid. In case the SecretCommits are valid, but this dkg can't verify its
    /// share, it returns a ComplaintCommits that must be broadcasted to every other
    /// participant. It returns Ok(None) otherwise.
    pub fn process_secret_commit(
        &mut self,
        sc: &SecretCommits,
    ) -> Result<Option<ComplaintCommits>, Box<dyn Error>> {
        let pub_k: &GE = self
            .participants
            .get(sc.index as usize)
            .ok_or_else(|| simple_error!("dkg: secretcommits received with index out of bounds"))?;

        if !self.is_in_qual(sc.index) {
            bail!("dkg: secretcommits from a non QUAL member");
        }

        // mapping verified by is_in_qual
        let v: &mut vssVerifier = self.verifiers.get_mut(&sc.index).unwrap();

        if !bitwise_eq(&v.session_id(), &sc.session_id) {
            bail!("dkg: secretcommits received with wrong session id");
        }

        let msg: [u8; 32] = SecretCommits::hash(&sc.commitments, sc.index)?;
        sign::verify_signature(
            &pub_k.get_element().to_bytes(),
            &sc.signature,
            &msg,
            &sc.index.to_le_bytes(),
        )
        .map_err(|e| simple_error!("dkg: invalid signature in SecretCommit: {}", e))?;

        let deal: vssDeal = v.get_deal().unwrap();
        let commitments: Vec<GE> = sc
            .commitments
            .iter()
            .map(|x| ECPoint::from_bytes(x))
            .collect::<Result<Vec<_>, _>>()
            .map_err(|x| simple_error!("Error while constructing point from bytes: {}", x))?;

        let polynomial: PubPoly = PubPoly::new(ECPoint::generator(), commitments);
        if polynomial.check(&deal.sec_share) {
            self.commitments.insert(sc.index, polynomial);
            Ok(None)
        } else {
            let msg: [u8; 32] = ComplaintCommits::hash(self.index, sc.index, &deal)?;
            let signature = sign::sign_msg(
                self.long.get_element().to_bytes(),
                self.pub_key.get_element().to_bytes(),
                &msg,
                &self.index.to_le_bytes(),
            )?;
            Ok(Some(ComplaintCommits {
                index: self.index,
                dealer_index: sc.index,
                deal,
                signature,
            }))
        }
    }

    /// process_complaints_commits takes any ComplaintCommits revealed through
    /// process_secret_commits() from other participants in QUAL. It returns the
    /// ReconstructCommits message that must be  broadcasted to every other participant
    /// in QUAL so the polynomial in question can be reconstructed.
    pub fn process_complaints_commits(
        &mut self,
        complaint_commits: &ComplaintCommits,
    ) -> Result<ReconstructCommits, Box<dyn Error>> {
        let issuer: &GE = self
            .participants
            .get(complaint_commits.index as usize)
            .ok_or_else(|| simple_error!("dkg: commitcomplaint with unknown issuer"))?;

        if !self.is_in_qual(complaint_commits.index) {
            bail!("dkg: complaintcommit from non-qual member");
        }

        let msg: [u8; 32] = ComplaintCommits::hash(
            complaint_commits.index,
            complaint_commits.dealer_index,
            &complaint_commits.deal,
        )?;
        sign::verify_signature(
            &issuer.get_element().to_bytes(),
            &complaint_commits.signature,
            &msg,
            &complaint_commits.index.to_le_bytes(),
        )
        .map_err(|e| simple_error!("dkg: invalid signature in SecretCommit: {}", e))?;

        let verifier = self
            .verifiers
            .get_mut(&complaint_commits.dealer_index)
            .ok_or_else(|| simple_error!("dkg: commit complaint linked to unknown verifier"))?;

        // the verification should pass for the deal, and not with the secret
        // commits. Verification 4) in DKG Rabin's paper.
        complaint_commits
            .deal
            .verify(verifier.verifiers(), verifier.session_id())
            .map_err(|e| simple_error!("dkg: verifying deal: {:?}", e))?;

        let secret_commit = self
            .commitments
            .get(&complaint_commits.dealer_index)
            .ok_or_else(|| simple_error!("dkg: complaint about non received commitments"))?;

        if secret_commit.check(&complaint_commits.deal.sec_share) {
            bail!("dkg: invalid complaint, deal verifying");
        }

        let deal = verifier.get_deal()?;

        self.commitments.remove(&complaint_commits.dealer_index);

        let msg: [u8; 32] =
            ReconstructCommits::hash(self.index, complaint_commits.dealer_index, &deal.sec_share)?;
        let signature = sign::sign_msg(
            self.long.get_element().to_bytes(),
            self.pub_key.get_element().to_bytes(),
            &msg,
            &self.index.to_le_bytes(),
        )?;

        let rc = ReconstructCommits {
            session_id: complaint_commits.deal.session_id.clone(),
            index: self.index,
            dealer_index: complaint_commits.dealer_index,
            share: deal.sec_share,
            signature,
        };

        self.pending_reconstruct
            .entry(complaint_commits.dealer_index)
            .or_default()
            .push(rc.clone());

        Ok(rc)
    }

    /// process_reconstruct_commits takes a ReconstructCommits message and stores it
    /// along any others. If there are enough messages to recover the coefficients of
    /// the public polynomials of the malicious dealer in question, then the
    /// polynomial is recovered.
    pub fn process_reconstruct_commits(
        &mut self,
        rs: &ReconstructCommits,
    ) -> Result<(), Box<dyn Error>> {
        if self.reconstructed.contains(&rs.dealer_index) {
            return Ok(());
        }

        if self.commitments.get(&rs.dealer_index).is_some() {
            bail!("dkg: commitments not invalidated by any complaints")
        }

        let pub_k = self
            .participants
            .get(rs.index as usize)
            .ok_or_else(|| simple_error!("dkg: reconstruct commits with invalid verifier index"))?;

        let msg: [u8; 32] = ReconstructCommits::hash(rs.index, rs.dealer_index, &rs.share)?;
        sign::verify_signature(
            pub_k.get_element().to_bytes().as_ref(),
            rs.signature.as_ref(),
            msg.as_ref(),
            rs.index.to_le_bytes().as_ref(),
        )
        .map_err(|e| simple_error!("dkg: invalid signature in ReconstructCommits: {}", e))?;

        let rec_comms = self.pending_reconstruct.entry(rs.dealer_index).or_default();
        // check if packet is already received or not
        // or if the session ID does not match the others
        for rec_comm in rec_comms.iter() {
            if rec_comm.index == rs.index {
                return Ok(());
            }
            if !bitwise_eq(rec_comm.session_id.as_ref(), rs.session_id.as_ref()) {
                bail!("dkg: reconstruct commits invalid session id");
            }
        }
        rec_comms.push(rs.clone());

        // check if we can reconstruct commitments
        if rec_comms.len() as u32 >= self.t {
            let mut shares: Vec<PriShare<FE>> = Vec::new();
            for el in rec_comms.iter() {
                shares.push(el.share.clone());
            }
            // error only happens when you have less than t shares, but we ensure
            // there are more just before
            let pri_poly: PriPoly = poly::recover_pri_poly(&mut shares, self.t as u32)?;
            let commit: PubPoly = pri_poly.commit(None);
            self.commitments.insert(rs.dealer_index, commit);
            // note it has been reconstructed.
            self.reconstructed.insert(rs.dealer_index);
            self.pending_reconstruct.remove(&rs.dealer_index);
        }

        Ok(())
    }

    /// finished returns true if the DKG has operated the protocol correctly and has
    /// all necessary information to generate the DistKeyShare() by itself. It
    /// returns false otherwise.
    pub fn finished(&self) -> bool {
        let mut nb: u32 = 0;
        for (i, v) in self.verifiers.iter() {
            if v.deal_certified() {
                nb += 1;
                // ALL QUAL members should have their commitments by now either given or
                // reconstructed.
                if self.commitments.get(i).is_none() {
                    return false;
                }
            }
        }
        nb >= self.t
    }

    /// dist_key_share generates the distributed key relative to this receiver
    /// It throws an error if something is wrong such as not enough deals received.
    /// The shared secret can be computed when all deals have been sent and
    /// basically consists of a public point and a share. The public point is the sum
    /// of all aggregated individual public commits of each individual secrets.
    /// the share is evaluated from the global Private Polynomial, basically SUM of
    /// fj(i) for a receiver i.
    pub fn dist_key_share(&self) -> Result<DistKeyShare, Box<dyn Error>> {
        if !self.certified() {
            bail!("dkg: distributed key not certified")
        }

        let mut sh: FE = ECScalar::zero();
        let mut pub_poly: Option<PubPoly> = None;
        for (i, v) in self.verifiers.iter() {
            if v.deal_certified() {
                // share of dist. secret = sum of all share received.
                let s: FE = v.get_deal().unwrap().sec_share.v;
                sh = sh.add(&s.get_element());
                // Dist. public key = sum of all revealed commitments
                let poly = self.commitments.get(&i).ok_or_else(|| {
                    simple_error!("dkg: protocol not finished: commitments from {} missing", i)
                })?;
                if pub_poly.is_none() {
                    // first polynomial we see (instead of generating n empty commits)
                    pub_poly.replace(poly.clone());
                    continue;
                }
                let sum_poly: PubPoly = pub_poly.unwrap().add(poly)?;
                pub_poly = Some(sum_poly);
            }
        }

        let (_, commits): (_, Vec<GE>) = pub_poly.unwrap().info();

        Ok(DistKeyShare {
            commits,
            share: PriShare {
                i: self.index,
                v: sh,
            },
        })
    }

    pub fn index(&self) -> u32 {
        self.index
    }
}

impl DistKeyShare {
    // get_public_key returns the public key associated with the distributed private key.
    pub fn get_public_key(&self) -> GE {
        self.commits[0]
    }

    pub fn get_pri_share(&self) -> PriShare<FE> {
        self.share.clone()
    }

    pub fn get_commitments(&self) -> &[GE] {
        &self.commits
    }
}

impl SecretCommits {
    /// hash returns the hash value of data used in the signature process.
    pub fn hash(commitments: &[Vec<u8>], index: u32) -> Result<[u8; 32], Box<dyn Error>> {
        let mut hasher = Sha256::new();
        hasher.write_all(b"secretcommits".as_ref()).unwrap();
        hasher.write_all(&index.to_le_bytes()).unwrap();
        for comm in commitments.iter() {
            hasher.write_all(comm.as_ref()).unwrap();
        }
        let result = hasher.result().as_slice().try_into()?;
        Ok(result)
    }
}

impl ComplaintCommits {
    /// hash returns the hash value of this struct used in the signature process.
    pub fn hash(index: u32, dealer_index: u32, deal: &vssDeal) -> Result<[u8; 32], Box<dyn Error>> {
        let deal_buff: Vec<u8> = bincode::serialize(deal)?;

        let mut hasher = Sha256::new();
        hasher.write_all(b"commitcomplaint".as_ref())?;
        hasher.write_all(&index.to_le_bytes())?;
        hasher.write_all(&dealer_index.to_le_bytes())?;
        hasher.write_all(deal_buff.as_ref())?;

        let result = hasher.result().as_slice().try_into()?;
        Ok(result)
    }
}

impl ReconstructCommits {
    /// hash returns the hash value of this struct used in the signature process.
    pub fn hash(
        index: u32,
        dealer_index: u32,
        sec_share: &PriShare<FE>,
    ) -> Result<[u8; 32], Box<dyn Error>> {
        let mut hasher = Sha256::new();
        hasher.write_all(b"reconstructcommits".as_ref())?;
        hasher.write_all(&index.to_le_bytes())?;
        hasher.write_all(&dealer_index.to_le_bytes())?;
        hasher.write_all(sec_share.hash().as_ref())?;

        let result = hasher.result().as_slice().try_into()?;
        Ok(result)
    }
}